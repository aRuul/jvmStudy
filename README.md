# 概述

## java虚拟机JVM

java虚拟机是一台执行java字节码的虚拟计算机，它拥有独立的运行机制，其运行的java字节码也未必由java语言编译而成。

JVM平台的各种语言可以共享java虚拟机带来的跨平台性、优秀的垃圾回收机制以及可靠的即时编译器。java技术的核心就是java虚拟机（jvm，java virtual machine）

## JVM的位置

![image-20210716200357558](https://gitee.com/aruul/a-ru-img/raw/master/img/20210716200358.png)

jvm是运行在操作系统之上的，没有和硬件直接交互

## JVM的整体结构

![image-20210716200826280](https://gitee.com/aruul/a-ru-img/raw/master/img/20210716200827.png)

​															==要求会自己画出这张图==

- HotSport VM是目前市面上最高性能的虚拟机的代表作之一。
- 它采用解释器与即时编译器并存的架构

## java代码执行流程

比如我们现在写了一个 HelloWorld.java 好了，那这个 HelloWorld.java 抛开所有东西不谈，那是不是就类似于一个文本文件，只是这个文本文件它写的都是英文，而且有一定的缩进而已。

那我们的 **JVM** 是不认识文本文件的，所以它需要一个 **编译** ，让其成为一个它会读二进制文件的 **HelloWorld.class**

如果 **JVM** 想要执行这个 **.class** 文件，我们需要将其装进一个 **类加载器** 中，它就像一个搬运工一样，会把所有的 **.class** 文件全部搬进JVM里面来。

![image-20210716200204379](https://gitee.com/aruul/a-ru-img/raw/master/img/20210716200206.png)

==由于跨平台的设计，java的指令都是根据栈来设计的。==跨平台性，指令集小，指令多。

相对于基于寄存器的架构，基于栈的架构的执行性能相比寄存器来说要差一些

## JVM的生命周期

**java虚拟机的启动**是通过引导类类(bootstrap class loader)创建一个初始化类(initial class)来完成，这个类是有虚拟机的具体实现指定的。

**虚拟机的执行:** 一个运行中的Java虚拟机有着一个清晰的任务：执行Java程序
程序开始执行时他才运行，程序结束时他就停止
执行一个所谓的Java程序的时候，真真正正在执行的是一个叫做Java虚拟机的进程

**虚拟机的退出**
有如下的几种情况：

- 程序正常执行结束
- 程序在执行过程中遇到了异常或错误而异常终止
- 由于操作系统出现错误而异致Java虚拟机进程终止
- 某线程调用 Runtime类或 system类的exit方法，或 Runtime类的halt
  方法，并且Java安全管理器也允许这次exit或halt操作
- 除此之外，JNI( Java Native Interface)规范描述了用JNI Invocation APｴ来加载或卸载Java虚拟机时，Java虚拟机的退出情况

## HotSpot虚拟机

不管是JDK6还是最常用的JDK8，默认虚拟机都是HotSpot

> 名称中的 Hotspot指的就是它的热点代码探测技术。
> 通过计数器找到最具编译价值代码，触发即时编译或上替拧
> 通过编译器与解释器协同工作，在最优化的程序响应时间与最佳执行性能中取得平衡

---

Graal VM  ---"Run Programs Faster Anywhere"  最有可能替代HotSpot。

# 类加载子系统

![image-20210717153811503](https://gitee.com/aruul/a-ru-img/raw/master/img/20210717153813.png)

**加载--> 链接--> 初始化**

**如果自己手写一个java虚拟机的话，主要考虑哪些结构？  类加载器和执行引擎**

## 类的加载过程

![image-20210717154600485](https://gitee.com/aruul/a-ru-img/raw/master/img/20210717154605.png)

- 类加载子系统负责从文件系统或者网络系统中加载Class文件，class文件在文件开头有特定的文件标识
- ClassLoader只负责class文件的加载，至于它是否可以运行，则是由Execution Engine来jued
- 加载的**类信息存放在一块成为方法区**的内存空间。
- 除了类的信息之外，**方法区还会存放运行时的常量池信息**，可能还包括**字符串常量和数字常量**（这部分常量信息是Class文件中常量池部分的内存映射）

---

具体的类加载过程图

![image-20210717160035120](https://gitee.com/aruul/a-ru-img/raw/master/img/20210717160036.png)

### 第一步 加载 --生成 java.lang.Class对象

1. 通过一个类的全限定名获取此类的二进制字节流
2. 将这个字节流所代表的静态数据结构转化为方法区的运行时数据结构
3. 在内存中**生成**一个代码这个类的  **java.lang.Class对象**，作为方法区这个类的各种数据的访问入口

### 第二步 链接

#### 1.**验证( Verify):**

- 目的在于确保class文件的字节流中包含信息符合当前虚拟机要求，保证被加载类的正确性，不会危害虚拟机自身安全。
- 主要包括四种验证，文件格式验证，元数据验证，字节码验证，符号引用验证

> java .class文件开头是COFFBABE

#### 2.**准备( Prepare):**

- 为**类变量**分配内存并且设置该类变量的**默认初始值**，即零值。

  ```java
  class Demo{
      //这时a会被赋值为0，在初始化时才会被初始化为1
      private static int a = 1;
  }
  ```

- 这里**不包含用final修饰的 static**,因为**final在编译的时候就会分配了**，准备阶段会显式初始化

- 这里不会为实例变量分配初始化，类变量会分配在方法区中，而**实例变量**是会随着对象一起分
  配到**java堆**中。

#### 3.**解析( Resolve)**

- **将常量池内的符号引用转换为直接引用的过程**
- 事实上，解析操作住住会伴随着JVM在执行完初始化之后再执行。
- 符号引用就是一组符号来描述所引用的目标。符号引用的字面量形式明确定义在《java虚拟机规范》的Class文件格式中。直接引用就是直接指向目标的指针、相对偏移量或一个间接定位到目标的句柄。
- 解析动作主要针对类或接口、字段、类方法、接口方法、方法类型等。对应常量池中的
  CONSTANT Class info CONSTANT Fieldref info, CONSTANT Methodref info

### 第三步 初始化

- 初始化阶段就是执行**类的构造器方法 clinit** 的过程（cl可以理解为 class  ，init为 inital）

- 此方法不需要定义，是javac编译器自动收集类中的所有变量的赋值动作和静态代码块中的语句合并而来的。

- 构造器方法按语句顺序执行所有**类变量**（static修饰的成员变量）显式初始化和**静态代码块中语句**

  ```java
  /*这里的话，a最终的值为1
  * 首先在第二步链接的准备阶段，会将a初始化为0
  * 在第三步初始化时，类的构造器方法按照顺序执行，先将a赋值为10，再将a赋值为1，所以最后a=1
  */
  class Demo{
      static{
          a = 10;
      }
      private static int a = 1;
  }
  ```

- **类的构造器方法 clinit**不同于类的构造函数，==当一个类中不存在类变量的时候，则.class文件中没有<clinit>()==

- 若该类有父类，JVM会保证父类的 clinit()执行完毕之后再执行子类的clinit()

  ```java
  class Father{
      public static int a = 1;
      static{
          a = 2;
      }
  }
  
  class Son extends Father{
      public static int b = a;
      
      public static void main(String []args){
          //最终的结果为2
          Sysytem.out.println(Son.b);
      }
  }
  ```

- 虚拟机必须保证一个类的<clinit>方法在多线程下被同步加锁，即==一个类只会被加载一次==

## 类的加载器

### 类加载器分类

JVM支持**两种**类型的**类加载器**，分别为

1. **引导加载器**(Bootstrap ClassLoader)
2. **自定义加载器(**User-Defined ClassLoader)，**是指继承自ClassLoader的加载器**

---

### 虚拟机自带的加载器

![image-20210718143802701](https://gitee.com/aruul/a-ru-img/raw/master/img/20210718143804.png)

#### 启动类加载器(引导类加载器 Bootstrap ClassLoader)

- 我们不能直接获取到

- java的**核心类库**都是使用**引导类加载器**来进行加载的。
- 这个类加载使用C++/C来实现的，嵌套在JVM内部
- 并不继承于java.lang.ClassLoader
- **加载扩展类和程序类加载器，并指定为它们的父加载器**
- 出于安全考虑，Bootstrap启动类加载器**只加载包名为java、javax、sun等开头的类**

#### 拓展类加载器(Extension ClassLoader)

- java语言编写
- 派生于ClassLoader类
- 父加载器为启动类加载器
- 从java。ext.dirs系统属性所指定的目录中加载类库，或者从JDK安装目录的jre/lib/ext子目录下加载类库。**如果用户创建的jar在此目录下，也会自动由扩展类加载器加载**

#### 应用程序类加载器(系统类加载器AppClassLoader)

- java语言编写
- 派生于ClassLoader类
- **父加载器为拓展类加载器**
- 负责加载**环境变量classpath**或**系统属性java.class.path**指定路径下的类库
- **我们自己写的类中默认加载器就是应用程序类加载器**

### 用户自定义加载类

![image-20210718151625921](https://gitee.com/aruul/a-ru-img/raw/master/img/20210718151628.png)

## ClassLoader

**ClassLoader类是一个抽象类，其后所有的类加载器都继承自ClassLoader(不包括启动加载类)**

这里暂且了解就够了（嗯，大概

## 双亲委派机制

> Java虚拟机对class文件采用的是**按需加载**的方式，也就是需要的时候才会将它的class文件加载到内存，生成class对象。
>
> 而在加载某个类的class文件时，JVM采用**双亲委派模式**，即把请求交给父类处理，是一种任务委派模式。

**双亲委派机制**：

1. 当一个类加载器收到了加载请求时，它是不会先自己去尝试加载的，而是委派给父类去完成，

2. 如果父类还有父类加载器，则进一步向上委托，以此类推，直到顶层的启动类加载器
3. 如果父类加载器可以完成加载任务，则成功返回；否则，子类加载器尝试去加载

==可以理解为 类加载器这个家族很重亲情，能爸爸做的就爸爸做，爸爸实在做不了就儿子做==

![image-20210718154731162](https://gitee.com/aruul/a-ru-img/raw/master/img/20210718154732.png)

优势：

- 避免类的重复加载

- 保护程序的安全，防止核心api被随意的篡改

  比如你自定义一个包 java.lang,包下面有一个类Demo

  ```java
  package java.lang
  class Demo{
      public static void main(String[] args){
          System.out.println("test");
      }
  }
  ```

  当你运行的时候，由于双亲委派机制，这和Demo类是java开头的，所以最终的加载器是引导类加载器。(引导类加载器只加载包名为java、javax、sun等开头的类)，而java核心类包中并没有Demo这个类，所以就会报错。

## 其他小的点

### 在JVM中表示两个class对象相同的两个必要条件：

1. 类的完整类名要一致，包括包名
2. 加载 这个类的ClassLoader(指ClassLoader实例对象)必须相同。

### 对类加载器的引用

1. JVM必须知道一个类型是由启动加载器加载的还是由用户类加载器加载的。
2. 如果一个类型是由用户类加载器加载的，那么JVM会将这个类加载器的一个引用作为类型信息的一部分保存在方法区中。
3. 当解析一个类型到另一个类型的引用的时候，JVM需要保证这两个类型的类加载器是相同的



----

# 运行时数据区

<img src="https://gitee.com/aruul/a-ru-img/raw/master/img/20210718163557.png" alt="image-20210718163554539" style="zoom:80%;" />

   红色的为**线程共享区域**，**一个虚拟机实例对应一份**

​	**蓝色的是一个线程对应一份**

## 程序计数器(PC计数器)

> **实际上，JVM中的程序计数器(PC计数器)是对物理pc寄存器的一种抽象模拟**，并非是广义上的物理寄存器。
>
> 
>
> 程序计数器其实就是一个指针，它指向了我们程序中下一句需要执行的指令，它也是内存区域中唯一一个不会出现OutOfMemoryError的区域，而且占用内存空间小到基本可以忽略不计。这个内存仅代表当前线程所执行的字节码的行号指示器，字节码解析器通过改变这个计数器的值选取下一条需要执行的字节码指令。
>
> 如果执行的是native方法，那这个指针就不工作了。

**程序计数器其实就是一个指针，它指向了我们程序中下一句需要执行的指令**

**每个线程都有自己的程序计数器**，生命周期与线程一致。

**作用**： PC寄存器用来存储指向下一条指令的地址，也即将要执行的指令代码。由执行引擎读取下一条指令。

下面是一个java代码的字节码文件main方法的一部分：

![image-20210719150122811](https://gitee.com/aruul/a-ru-img/raw/master/img/20210719150124.png)

### 使用PC寄存器存储字节码指令地址有什么用呢？

(为什么使用PC寄存器记录当前线程的执行地址呢？)

因为CPU需要不停的切换各个线程，这时候切换回来以后，就得知道接着从哪开始继续执行。
JVM的字节码解释器就需要通过改变PC寄存器的值来明确下一条应该执行什么样的字节码指令。

### PC寄存器为什么会被设定为线程私有？

cpu在执行多线程的时候，实际上会不停地做任务切换，这样必然导致经常中断或恢复，如何保证分毫无差呢？为了能够准确地记录各个线程正在执行的当前字节码指令地址，最好的办法自然是为每一个线程都分配一个PC寄存器，这样一来各个线程之间便可以进行独立计算，从而不会出现相互干扰的情况。

### 并行 并发

- **并发：** 同一时间段，多个任务都在执行 (单位时间内不一定同时执行)；
- **并行：** 单位时间内，多个任务同时执行（可以与串行相理解）

## 虚拟机栈

**栈管运行，堆管存储。则虚拟机栈负责运行代码，而虚拟机堆负责存储数据。**

> Java虚拟机栈( Java virtua1 Machine Stack),早期也叫Java栈。
> 每个线程在创建时都会创建一个虚拟机栈，其内部保存一个个的栈帧( Stack Frame),对应着一次次的Java方法调用。
>
> **是线程私有的**

- **作用**：主管java程序的运行，它保存方法的局部变量(8中基本数据类型/对象的引用)、部分结果，并参与方法的调用和返回。

- **优点：**1. 栈是一种快速有效的分配存储方式，访问速度仪次于程序计数器。

  ​			2.JVM直接对Java栈的操作只有两个：每个方法执行，伴随着进（入栈、压栈）、执行结束后的出栈工作

  ​			3.对于栈来说不存在垃圾回收问题

#### 异常

如果线程请求的栈的深度大于虚拟机栈的最大深度，就会报 **StackOverflowError** （这种错误经常出现在**递归中**）。

Java虚拟机也可以动态扩展，但随着扩展会不断地申请内存，当无法申请足够内存时就会报错 **OutOfMemoryError**(OOM)。

#### 设置栈内存大小

我们可以使用**参数-Xss选项来设置线程的最大栈空间**，栈大小直接决定了函数调用的最大可达深度。

#### 栈的存储单元-栈帧

- 每个线程都有自己的栈，栈中的数据都是以**栈帧( Stack Frame)**格式存在。
- 在这个线程上正在执行的**每个方法**都各自**对应一个栈帧( Stack Frame)**
- 栈帧是一个内存区块，是一个数据集，维系着方法执行过程中的各种数据信息。
- 在一条活动线程中，一个时间点上，只会有一个活动的栈帧。
  - 即只有当前正在执行的方法的栈帧（**栈顶栈帧**）是有效的，这个栈帧被称为**当前栈帧( Current Frame)**,
  - 与**当前栈帧相对应的方法就是当前方法**（ CurrentMethod),
  - 定义这个方法的类就是**当前类**( Current Class).
- **执行引擎运行的所有字节码指令只针对当前栈帧进行操作**
  如果在该方法中调用了其他方法，对应的新的栈帧会被创建出来，放在栈的顶端，成为新的当前帧。

<img src="https://gitee.com/aruul/a-ru-img/raw/master/img/20210719160147.png" alt="QQ图片20210719160131" style="zoom:80%;" />

- Java方法有两种返回函数的方式，一种是正常的函数返回，使用 return指令；另外一种是抛出异常。**不管使用哪种方式，都会导致栈帧被弹出。**
- 不同线程中所包含的栈帧是不允许存在相互引用的，即不可能在一个栈帧之中引用另外一个线程的栈帧。
- 如果当前方法调用了其他方法，方法返回之际，当前栈帧会传回此方法的执行结果给前一个栈帧，接着，虚拟机会丢弃当前栈帧，使得前一个栈帧重新成为当前栈帧

#### 栈帧的内部结构【ToDo】

(这里我并没有仔细看，所以只粗略了写了一小点内容)

![image-20210719161844500](https://gitee.com/aruul/a-ru-img/raw/master/img/20210719161847.png)

- 局部变量表( Local Variables)

  ​     **定义为数字数组**

  ​	**局部变量表，最基本的存储单元是Slot（变量槽）**

  ![image-20210719162352247](https://gitee.com/aruul/a-ru-img/raw/master/img/20210719162353.png)

- 操作数栈( operand stack)（或表达式）

  > 操作数栈，在方法执行过程中，根据字节码指令，在栈中写入数据或者提取数据，即入栈、出栈

- 动态链接( Dynamic Linking)（或指向运行时常量池的方法引用）

  > 每个栈帧内部都包含一个指向运行时常量池中该栈帧所属方法的引用。包含这个引用的目的就是为了支持当前方法的代码能够实现**动态链接**
  >
  > 在Java源文件被编译到字节码文件中时，所有的变量和方法引用都作为**符号引用**( Symbolic Reference)保存在class文件的常量池里。
  > 比如：描述一个方法调用了另外的其他方法时，就是通过常量池中指向方法的符号引用来表示的，那么**动态链接的作用就是为了将这些符号引用转换为调用方法的直接引用**

- 方法返回地址( Return Address)（或方法正常退出或者异常退出的定义）

  > 无论通过哪种方式退出，在方法退出后都返回到该方法被调用的位置。
  >
  > 方法正常退出时，调用者的pc计数器的值作为返回地址，即调用该方法的指令的下一条指令的地址。
  >
  > 而通过异常退出的，返回地址是要通过异常表来确定，栈帧中一般不会保存这部分信息。

- 一些附加信息

  > 栈帧中还允许携带与Java虚拟机实现相关的一些附加信息。例如，对程序调试提供支持的信息。

#### 静态变量和局部变量

  **局部变量在使用前一定要显式赋值，否则编译不通过**

> 我们知道类变量表有两次初始化的机会，第一次是在“准备阶段”，执行系统初始化，对类变量设置零值，
>
> 另一次则是在“初始化”阶段，赋予程序员在代码中定义的初始值。
> 和类变量初始化不同的是，局部变量表不存在系统初始化的过程，这意味着一旦定义了局部变量则必须人为的初始化，否则无法使用。

**补充：**

- 在栈帧中，与性能调优关系最为密切的部分就是前面提到的局部变量表。在方法执行时，虚拟机使用局部变量表完成方法的传递。
- 局部变量表中的变量也是重要的垃圾回收根节点，只要被局部变量表中直接或间接引用的对象都不会被回收。

#### java中方法重写的本质？

![image-20210720135306618](https://gitee.com/aruul/a-ru-img/raw/master/img/20210720135308.png)

#### 举例栈溢出的情况？

如果线程请求的栈的深度大于虚拟机栈的最大深度，就会报 **StackOverflowError** （这种错误经常出现在递归中）。

#### 调整栈大小，就能保证不出现溢出吗？

使用参数-Xss选项来设置线程的最大栈空间，但不一定保证不出现溢出，如果碰到递归，可能会出现溢出。

#### 分配的栈内存越大越好吗？

并不是，栈是私有的，如果设置的每一个栈的空间太大了，就会导致最后可分配的线程数量变少，甚至出OOM

#### 垃圾回收是否会涉及到虚拟机栈？

不会，他直接操作的就是出栈、入栈，不存在GC(垃圾回收)，存在Error

#### 方法中定义的局部变量是否线程安全？【ToDo】

视情况而定

## 本地方法接口的理解

![ ](https://gitee.com/aruul/a-ru-img/raw/master/img/20210720135756.png)



> **本地方法(Native Method)**：一个 Native Method就是一个Java调用非Java代码的接口。
>
> 一个Native Method是这样一个Java方法：该方法的实现由非Java语言实现，比如C，这个特征并非Java所特有，很多其它的编程语言都有这一机制，比如在C++中你可以用 extern"C"告知C++编译器去调用一个C的函数。

## 本地方法栈

Java虚拟机栈用于管理Java方法的调用，而本地方法栈用于管理本地方法的调用。

> 并不是所有的JVM都支持本地方法。因为Java虚拟机规范并没有明确要求本地方法栈的使用语言、具体实现方式、数据结构等。
>
> 如果JVM产品不打算支持 native方法，也可以无需实现本地方法栈。
> 在 Hotspot JVM中，直接将本地方法栈和虚拟机合二为一。

## 堆(heap)

![image-20210720144022441](https://gitee.com/aruul/a-ru-img/raw/master/img/20210720144023.png)

**堆是线程共享区域**

### 核心概念

- **一个JVM实例只存在一个堆内存**，堆也是Java内存管理的核心区域。

  ***即，每个Java应用程序都使用一个独立的 JVM。***

- **Java堆区在JVM启动的时候即被创建，其空间大小也就确定了**，是JVM管理的最大一块内存空间。
  堆内存的大小是可以调节的。

- 《Java虚拟机规范》规定，堆可以处于**物理上不连续的内存空间**中，但在**逻辑上它应该被视为连续**的。

- 所有的**线程共享java堆**，在这里还可以划分线程**私有的缓冲区**（ Thread Local Allocation Buffer, TLAB)

- **所有的对象实例以及数组都应当在运行时分配在堆上**。( The heap is the run- time data area from
  which memory for all class instances and arrays is allocated
  *周老师说的是：“几乎”所有的对象实例都在这里分配内存。---------从实际使用角度看的。*

- **数组和对象可能永远不会存储在栈上**，因为栈帧中保存引用，这个引用指向对象或者数组在堆中的位置。

- **在方法结束后，堆中的对象不会马上被移除，仅仅在垃圾收集的时候才会被移除。**

- 堆，是GC( Garbage Collection,垃圾收集器)执行垃圾回收的重点区域

---

![image-20210720145811206](https://gitee.com/aruul/a-ru-img/raw/master/img/20210720145812.png)

​														栈 、堆、方法区之间的关系

---

### 堆的细分内存结构

在JDK7以及之前的版本，堆通常被分为下面三个部分：

1. **新生区(Yong Generation)**
2. **养生区(Old Generation)**
3. 永久区/永久代(Permanent Generation)

Java8及之后堆内存逻辑上分为三部分：

1. **新生区**

   **年轻代**又可以划分为**Eden空间、 Survivor0空间和 Survivor1空间**（有时也叫做from区、to区）。

2. **养老区**

3. 元空间

> 由于翻译不同 叫法也不尽相同，下面是常见的叫法：
>
> 新生区=新生代= 年轻代   
> 养老区 =老年区 =老年代
> 永久区 =永久代

### 设置堆空间大小

Java堆区用于存储Java对象实例，堆的大小在JVM启动时就已经设定好了，

可以通过选项"-Xmx"和"Xms"来进行设置。

>**“-Xms"用于表示堆区的起始内存**，等价于ーXX: Initialheapsize
>**“-Xmx"则用于表示堆区的最大内存**，等价于-XX: Maxheaps1ze

### 年轻代与老年代

存储在JVM中的Java对象可以被划分为**两类**：

- **一类是生命周期较短的瞬时对象，这类对象的创建和消亡都非常迅速**
- **另外一类对象的生命周期却非常长，在某些极端的情况下还能够与JVM的生命周期保持一致。**

Java**堆区**进一步细分的话，可以划分为**年轻代**和**老年代**
其中**年轻代**又可以划分为**Eden空间、 Survivor0空间和 Survivor1空间**（有时也叫做from区、to区）。

==几乎所有的java对象都是在Eden区被new出来的。==

==绝大部分的java对象的销毁都在新生代进行==

![image-20210720154016863](https://gitee.com/aruul/a-ru-img/raw/master/img/20210720154018.png)

#### 调参与占比

新生代：老年代=1：2

新生代：Eden:s0:s1=8:1:1

![image-20210720154338541](https://gitee.com/aruul/a-ru-img/raw/master/img/20210720154339.png)



![image-20210720154605960](https://gitee.com/aruul/a-ru-img/raw/master/img/20210720154607.png)

### 对象分配的一般过程

> 1.new的对象先放伊甸园区。此区有大小限制。
>
> **【注意】大对象直接进入老年代，大对象就是需要大量连续内存空间的对象（比如：字符串、数组）。**
>
> 2.当伊甸园的空间填满时，程序又需要创建对象，JVM的垃圾回收器将对伊甸园区进行垃圾回收( Minor GC),将伊甸园区中的不再被其他对象所引用的对象进行销毁。再加载新的对象放到伊甸园区
>
> **【注意】只有伊甸园区的空间满的时候才会触发垃圾回收( Minor GC又叫YGC【Young GC】),幸存区满了并不会触发**
>
> 3.然后将伊甸园中的剩余对象移动到幸存者0区。
>
> 4.如果再次触发垃圾回收，此时上次幸存下来的放到幸存者0区的，如果没有回收，就会放到幸存者1区。
>
> 5.如果再次经历垃圾回收，此时会重新放回幸存者0区，接着再去幸存者1区。
>
> 6,啥时候能去养老区呢？可以设置次数。默认是15次。
> 可以设置参数：-XX: Maxtenuringthreshold=<N>进行设置

**针对幸存者s0,s1区的总结**：复制之后有交换，谁空谁是to

**关于垃圾回收**：频繁在新生区收集，很少在养老区收集，几乎不在永久区/元空间收集。

### 对象分配的特殊情况

![image-20210721151057588](https://gitee.com/aruul/a-ru-img/raw/master/img/20210721151059.png)

​																			配合P73来理解

### Minor GC、Major GC、Full GC

JVM在进行GC时，并非每次都对上面三个内存(新生代、老年代；方法区)区域一起回收的，**大部分时候回收的都是指新生代。**

针对 Hotspot JVM的实现，它里面的GC按照回收区域又分为两大种类型：

一种是**部分收集(Partial GC)**
一种是**整堆收集(Full GC)**

- 部分收集：不是完整收集整个java堆的垃圾收集。其中又分为：
  - 新生代收集( Minor GC/ Young GC):  只是新生代的垃圾收集
  - 老年代收集( Major GC/Old GC):  只是老年代的垃圾收集。
    *目前，只有 CMS GC会有单独收集老年代的行为。*
    ***注意，很多时候 Major GC会和Full GC混淆使用，需要具体分辨是老年代回收还是整堆回收。***
  - 混合收集( Mixed GC):收集整个新生代以及部分老年代的垃圾收集。
    *目前，只有G1 GC会有这种行为*
- 整堆收集(Full GC): 收集整个java堆和方法区的垃圾收集。

#### 年轻代GC( Minor GC)触发机制

- 当年轻代空间不足时，就会触发 Minor GC,这里的年轻代满指的是Eden代满， Survivor满不会引发GC。(每次 Minor GC会清理年轻代的内存）
- 因为java对象大多都具备**朝生夕灭**的特性，所以 **Minor GC非常频繁**，一般**回收速度也比较快**。这一定义既清晰又易于理解。
- Minor GC会引发STW,暂停其它用户的线程，等垃圾回收结束，用户线程才恢复运行

#### 老年代GC(Major GC)触发机制

- 指发生在老年代的GC,对象从老年代消失时，我们说“ Major GC”或“Full GC”发生了
- 出现了 Major GC，经常会伴随至少一次的 Minor GC(但非绝对的，在Parallel Scavenge收集器的收集策略里就有直接进行 Major GC的策略选择过程）。也就是在老年代空间不足时，会先尝试触发 Minor GC。如果之后空间还不足，则触发 Major Gc
- Major GC的速度一般会比 Minor GC慢10倍以上，STW的时间更长。
- 如果 Major GC后，内存还不足，就报OOM了

#### Full GC触发机制

触发Full GC执行的情况有如下五种：
(1)调用 System. gc()时，系统建议执行Full GC,但是不必然执行
(2)老年代空间不足
(3)方法区空间不足
(4)通过 Minor GC后进入老年代的平均大小大于老年代的可用内存
(5)由Eden区、 survivor spacee( From Space)区向 survivor space1(To Space)区复制时，对象大小大于 To Space可用内存，则把该对象转存到老年代，且老年代的可用内存小于该对象大小
*说明：full gc是开发或调优中尽量要避免的。这样暂时时间会短一些。*

**一般来说 出现OOM，则极大可能进行了Full GC**

### 为什么要把Java堆分代？不分代就不能正常工作了吗？

- 经研究，不同对象的生命周期不同。70%-99%的对象是临时对象。

  - 新生代：有Eden、两块大小相同的Survivor(又称作 s0/s1或from/to )构成，to总为空。
  - 老年代：存放新生代中经历多次GC依旧存活的对象

- 其实不分代完全可以，分代的唯一理由就是优化GC性能。

  - 如果没有分代，那所有的对象都在一块，就如同把一个学校的人都关在一个教室。GC的时候要找到哪些对象没用，这样就会对堆的所有区域进行扫描。
  - 而很多对象都是朝生夕死的，如果分代的话，把新创建的对象放到某一地方，当GC的时候先把这块存储“朝生夕死”对象的区域进行回收，这样就会腾出很大的空间出来。

---

###  针对不同年龄段的对象分配原则

- 优先分配到Eden

- 大对象直接分配到老年代：
  *尽量避免程序中出现过多的大对象*

- 长期存活的对象分配到老年代

- 动态对象年龄判断：
  **如果Survivor区中相同年龄的所有对象大小的总和 大于 Survivor空间的一半，年龄大于或等于该年龄的对象可以直接进入老年代，无须等到MaxTenuringThreshold中要求的年龄。**

  > **【比如】**：Survivor区中有6个相同年龄的对象，都是10岁，而且这6个对象占用的空间大于 Survivor空间的一半，则其他大于10岁的对象可以直接进入老年代。

- 空间分配担保：
  *-XX:HandlePromotionFailure ，也就是经过Minor GC后，所有的对象都存活，因为Survivor比较小，所以就需要将Survivor无法容纳的对象，存放到老年代中。*

### TLAB【ToDo】

**TLAB(Thread Local Allocation Buffer)中文意思是线程本地分配缓冲区**

#### 堆空间都是共享的么？

不一定，因为还有TLAB这个概念，**在堆中划分出一块区域，为每个线程所独占**

#### 为什么要有TLAB？

- TLAB：Thread Local Allocation Buffer，也就是为每个线程单独分配了一个缓冲区
- 堆区是线程共享区域，任何线程都可以访问到堆区中的共享数据
- 由于对象实例的创建在JVM中非常频繁，因此在并发环境下从堆区中划分内存空间是线程不安全的
- 为避免多个线程操作同一地址，需要使用加锁等机制，进而影响分配速度。

#### 小结

- 年轻代是对象的诞生、成长和消亡的区域，一个对象在这里产生、应用，最后被垃圾回收器收集、结束生命。

- 老年代放置长生命周期的对象。通常都是从Survivor区域筛选拷贝过来的java对象。

  普通的对象会被分配在TLAB上，当对象较大的，JVM会试图直接分配在Eden其他位置上

  当对象太大，无法在新生代找到足够长的连续空闲空间，JVM就会把对象直接分配到老年代。

- 当GC只发生在年轻代，回收年轻代对象的行为称为Minor GC。

  当GC发生在老年代，则被成为Major GC或者Full GC。

  一般来说，Minor GC的发生频率比Major GC要高，即年轻代中垃圾回收频率大大高于年轻代。

---

## 方法区

### 栈 堆 方法区的交互关系

<img src="https://gitee.com/aruul/a-ru-img/raw/master/img/20210722145839.png" alt="image-20210722145836188" style="zoom:50%;" />

> **方法区** 是用于存放类似于元数据信息方面的数据的，比如类信息，常量，静态变量，编译后代码···等
>
> 类加载器将 .class 文件搬过来就是先丢到这一块上
>
> **堆** 主要放了一些存储的数据，比如对象实例，数组···等，
>
> **栈** 这是我们的代码运行空间。我们编写的每一个方法都会放到 **栈** 里面运行。

上面的图中，new PerSon()相当于创建了一个对象实例，则放在**堆**中

Person存放了这个类的信息，存放在方法区中

person是存放在Java栈的局部变量表中

![image-20210722151405350](https://gitee.com/aruul/a-ru-img/raw/master/img/20210722151407.png)

### 方法区的基本理解

> 《java虚拟机规范》中明确说明：“尽管所有的**方法区在逻辑上是属于堆的一部分**，但一些简单的实现可能不会选择去进行垃圾收集或者进行压缩。”但对于HotSpot JVM而言，方法区还有一个别名叫Non-Heap(非堆)，目的就是要和堆分开。
>
> 所以，**方法区看作是独立于java堆的内存空间。**

- 方法区和堆一样，是各个线程共享的内存区域
- 方法区在jvm启动的时候被创建，而且他的实际物理内存空间中和java堆区一样都可以是不连续的
- 方法区的大小跟堆空间大小都可以选择固定大小或者可拓展
- 方法区的大小决定了系统可以保存多少个类，如果系统定义了太多的类，导致方法区溢出，虚拟机及同样会抛出内存溢出错误，
- 关闭JVM就会释放这个区域的内存

### 方法区的演进

**在 JDK7 及以前，习惯上把方法区，称为永久代。JDK8开始，使用元空间取代了永久代**

本质上，方法区和永久代并不等价

当年使用永久代，不是好的idea，因为实在JVM的内存中运行，导致Java程序更容易OOM

**而jdk1.8及以后，元空间不在虚拟机设置的内存中，而是使用本地内存**

<img src="https://gitee.com/aruul/a-ru-img/raw/master/img/20210722160956.png" alt="image-20210722160955144" style="zoom:80%;" />

<img src="https://gitee.com/aruul/a-ru-img/raw/master/img/20210722161025.png" alt="image-20210722161024342" style="zoom:80%;" />

### 方法区的内部结构

方法区主要存放的信息如下：

![image-20210722162315731](https://gitee.com/aruul/a-ru-img/raw/master/img/20210722162317.png)

《深入理解java虚拟机》中对方法区存储的内容描述如下：

> 它用于存储已被虚拟机加载的**类型信息**、**常量、静态变量**、**即时编译器编译之后的代码缓存**等。

**类型信息**：

包含了下面几个信息：

- 这个类的完整有效名称(全名=包名+类名)
- 这个类型直接父类的完整有效名(对于interface或者Object,都没有父类)
- 这个类型的修饰符(public,abstract,final)
- 这个类型直接接口的一个有序列表

**域信息**(成员变量)：

- JVM必须在方法区中保存类型的所有域相关的信息以及域的声明顺序。
- 域的相关信息包括：域名称、域类型、域修饰符(public、static、final、volatile等)

**non-final的类变量**

- 静态变量和类关联在一起，随着类的加载而加载，它们成为类数据在逻辑上一部分
- **类变量被所有的实例共享，即使没有类实例时也可以访问**

**【注意】被声明为final的类变量的处理方法则不同，每个全局常量在编译的时候就会被分配了**

**方法信息：**

- 方法名称
- 方法的返回类型(或void)
- 方法参数的数量和类型（按顺序）
- 方法的修饰符（ public, private, protected, static,final,synchronized, native, abstract的一个子集）
- 方法的字节码( bytecodes)、操作数栈、局部变量表及大小（ abstract和native方法除外）
- 异常表( abstract和 native方法除外)

### 常量池

在字节码文件内部，包含了**常量池**。

当通过类的加载器加载运行之后，就叫做**运行时常量池**。

- 一个有效的字节码文件中除了包含类的版本信息、字段、方法以及接口等描述符信息外
- 还包含一项信息就是**常量池表**（**Constant Pool Table**），包括**各种字面量和对类型、域和方法的符号引用**

#### 为什么需要常量池？

一个java源文件中的类、接口，编译后产生一个字节码文件。而Java中的字节码需要数据支持，通常这种数据会很大以至于不能直接存到字节码里，换另一种方式，可以存到常量池，所以我们将所需用到的结构信息记录在常量池中，并通过**引用的方式**，来加载、调用所需的结构。

#### 常量池里有什么？

- 数量值
- 字符串值
- 类引用
- 字段引用
- 方法引用

> **常量池，可以看做是一张表，虚拟机指令根据这张常量表找到要执行的类**
> **名、方法名、参数类型、字面量等类型。**

### 方法区的演进

|   JDK版本    |                           演变细节                           |
| :----------: | :----------------------------------------------------------: |
| JDK1.6及以前 |               有永久代，静态变量存储在永久代上               |
|    JDK1.7    | 有永久代，但已经逐步“去永久代”，**字符串常量池、静态变量从永久代中移除，保存在堆中** |
|    JDK1.8    | 无永久代，**类型信息、字段、方法、常量保存在本地内存的元空间**，但**字符串常量池、静态变量仍然在堆中**。 |

- JDK1.6

![image-20210723162257646](https://gitee.com/aruul/a-ru-img/raw/master/img/20210723162259.png)

- JDK1.7

![image-20210723162441857](https://gitee.com/aruul/a-ru-img/raw/master/img/20210723162443.png)

- JDK1.8

![image-20210723162528585](https://gitee.com/aruul/a-ru-img/raw/master/img/20210723162529.png)

#### 为什么永久代要被元空间替代？

> JRockit是和HotSpot融合后的结果，因为JRockit没有永久代，所以他们不需要配置永久代
>
> 随着Java8的到来，HotSpot VM中再也见不到永久代了。但是这并不意味着类的元数据信息也消失了。这些数据被移到了一个与堆不相连的本地内存区域，这个区域叫做元空间（Metaspace）。
>
> 由于类的元数据分配在本地内存中，元空间的最大可分配空间就是系统可用内存空间，这项改动是很有必要的，原因有：
>
> - 为永久代设置空间大小是很难确定的。
>
> 在某些场景下，如果动态加载类过多，容易产生Perm区的oom。比如某个实际Web工 程中，因为功能点比较多，在运行过程中，要不断动态加载很多类，经常出现致命错误。
>
> “Exception in thread‘dubbo client x.x connector'java.lang.OutOfMemoryError:PermGen space”
>
> 而元空间和永久代之间最大的区别在于：元空间并不在虚拟机中，而是使用本地内存。 因此，默认情况下，元空间的大小仅受本地内存限制。
>
> - 对永久代进行调优是很困难的。
>   - 主要是为了降低Full GC
>
> 有些人认为方法区（如HotSpot虚拟机中的元空间或者永久代）是没有垃圾收集行为的，其实不然。《Java虚拟机规范》对方法区的约束是非常宽松的，提到过可以不要求虚拟机在方法区中实现垃圾收集。事实上也确实有未实现或未能完整实现方法区类型卸载的收集器存在（如JDK11时期的ZGC收集器就不支持类卸载）。 一般来说这个区域的回收效果比较难令人满意，尤其是类型的卸载，条件相当苛刻。但是这部分区域的回收有时又确实是必要的。以前sun公司的Bug列表中，曾出现过的若干个严重的Bug就是由于低版本的HotSpot虚拟机对此区域未完全回收而导致内存泄漏
>
> 方法区的垃圾收集主要回收两部分内容：常量池中废弃的常量和不在使用的类型

#### String Table为什么要调整？

JDK7中将StringTable放在堆空间中。

因为永久代的回收效率很低，在Full GC时才会被执行永久代(方法区)的垃圾回收，而Full GC是老年代空间不足、永久代不足时才会触发。这就导致StringTable回收效率不高，而我们开发中会有大量的字符串被创建，回收效率低，导致永久代内存不足。

放到堆里，能及时回收内存。

#### 静态变量存放在哪里？

静态引用对应的对象实体始终都存在堆空间。

### 方法区的垃圾回收

实际上java虚拟机规范中并没有规定方法区一定要垃圾回收

方法区的垃圾收集主要回收两个部分：**常量池中废弃的常量**和**不再使用的类型**

常量池之中主要存放的两大类常量：字面量和符号引用。

字面量比较接近Java语言层次的常量概念，如文本字符串、被声明为final的常量值等。而符号引用则属于编译原理方面的概念，包括下面三类常量：

- 类和接口的全限定名
- 字段的名称和描述符
- 方法的名称和描述符

**HotSpot虚拟机对常量池的回收策略是很明确的，只要常量池中的常量没有被任何地方引用，就可以被回收。**

> 判定一个常量是否“废弃”还是相对简单，而要判定一个类型是否属于“不再被使用的类”的条件就比较苛刻了。需要同时满足下面三个条件：
>
> - 该类所有的实例都已经被回收，也就是Java堆中不存在该类及其任何派生子类的实例。 加载该类的类加载器已经被回收，这个条件除非是经过精心设计的可替换类加载器的场景，如osGi、JSP的重加载等，否则通常是很难达成的。
> - 该类对应的java.lang.C1ass对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。I Java虚拟机被允许对满足上述三个条件的无用类进行回收，这里说的仅仅是“被允许”，而并不是和对象一样，没有引用了就必然会回收。关于是否要对类型进行回收，HotSpot虚拟机提供了-Xnoclassgc参数进行控制，还可以使用-verbose:class 以及 -XX：+TraceClass-Loading、-XX：+TraceClassUnLoading查看类加载和卸载信息
> - 在大量使用反射、动态代理、CGLib等字节码框架，动态生成JSP以及oSGi这类频繁自定义类加载器的场景中，通常都需要Java虚拟机具备类型卸载的能力，以保证不会对方法区造成过大的内存压力。

## 小结

![image-20210724145709334](https://gitee.com/aruul/a-ru-img/raw/master/img/20210724145710.png)

## 大厂面试题

百度 三面：说一下JVM内存模型吧，有哪些区？分别干什么的？

蚂蚁金服： Java8的内存分代改进 JVM内存分哪几个区，每个区的作用是什么？ 一面：JVM内存分布/内存结构？栈和堆的区别？堆的结构？为什么两个survivor区？ 二面：Eden和survior的比例分配

小米： jvm内存分区，为什么要有新生代和老年代

字节跳动： 二面：Java的内存分区 二面：讲讲jvm运行时数据库区 什么时候对象会进入老年代？

京东： JVM的内存结构，Eden和Survivor比例。 

JVM内存为什么要分成新生代，老年代，持久代。新生代中为什么要分为Eden和survivor。

> - 如果没有Survivor，Eden区每进行一次Minor GC，存活的对象就会被送到老年代。老年代很快被填满，触发Major GC.老年代的内存空间远大于新生代，进行一次Full GC消耗的时间比Minor GC长得多,所以需要分为Eden和Survivor。
> - Survivor的存在意义，就是减少被送到老年代的对象，进而减少Full GC的发生，Survivor的预筛选保证，只有经历16次Minor GC还能在新生代中存活的对象，才会被送到老年代。
> - 设置两个Survivor区最大的好处就是解决了碎片化，刚刚新建的对象在Eden中，经历一次Minor GC，Eden中的存活对象就会被移动到第一块survivor space S0，Eden被清空；等Eden区再满了，就再触发一次Minor GC，Eden和S0中的存活对象又会被复制送入第二块survivor space S1（这个过程非常重要，因为这种复制算法保证了S1中来自S0和Eden两部分的存活对象占用连续的内存空间，避免了碎片化的发生）

天猫： 一面：Jvm内存模型以及分区，需要详细到每个区放什么。 一面：JVM的内存模型，Java8做了什么改

拼多多： JVM内存分哪几个区，每个区的作用是什么？

美团： java内存分配 jvm的永久代中会发生垃圾回收吗？ 一面：jvm内存分区，为什么要有新生代和老年代？

# 对象常见知识点

**首先，要明白对象是在堆中的。**

## 对象创建方式

- new :最常见的方式
- Class的newInstance方法
- Constructor的newInstance(XXX)，反射的方式，可以调用空参/带参的构造器
- 使用clone():不调用任何构造器，要求当前的类要实现Cloneable接口中的clone()
- 使用反序列化：从网络、文件中获取对象的二进制流
- 第三方库Objenesis

## 创建对象的步骤

### 1.判断对象对应的类是否加载、链接、初始化

- 虚拟机遇到一条new指令，首先检查这个指令的参数是否在Metaspace(元空间)的常量池中定位到一个类的符号引用，并且检查这个符号引用代表的类是否已经被加载、解析和初始化。
  - 如果没有，那么在双亲委派模式下，使用当前类加载器一ClassLoader+包名+类名为key进行查找对应的.class文件。
    - 如果没有找到文件，则抛出ClassNotFoundException异常，
    - 如果找到，则进行类的加载，并生成对应的Class类对象

> **符号引用**
> 符号引用以一组符号来描述所引用的目标，符号可以是任何形式的字面量，只要使用时能够无歧义地定位目标即可。符号引用与虚拟机实现的内存布局无关，引用的目标并不一定已经加载到内存中。

### 2.为对象分配内存

首先计算对象占用空间的大小，接着在堆中划分一块内存给新对象。如果实例成员变量是引用变量，仅分配引用变量空间即可，即4个字节大小。

在分配的内存空间的时候：

- 如果内存规整，使用的是**指针碰撞法**来分配内存
- 如果内存不规整，已使用的内存和未使用的内存相互交错，那么虚拟机使用**空闲列表**来分配。**意思是虚拟机维护了一个列表，记录上那些内存块是可用的，再分配的时候从列表中找到一块足够大的空间划分给对象实例，并更新列表上的内容。这种分配方式成为了 “空闲列表（Free List）”**

【补充】

**指针碰撞法**：意思是所有用过的内存在一边，空闲的内存放另外一边，中间放着一个指针作为分界点的指示器，分配内存就仅仅是把指针指向空闲那边挪动一段与对象大小相等的距离罢了。

<img src="https://gitee.com/aruul/a-ru-img/raw/master/img/20210724154035.png" alt="image-20210724154034553" style="zoom:80%;" />

<img src="https://gitee.com/aruul/a-ru-img/raw/master/img/20210724154221.png" alt="image-20210724154220080" style="zoom:80%;" />

### 3.处理并发安全问题

- 采用CAS配上失败重试保证更新的原子性
- 每个线程预先分配TLAB -----通过设置 -XX:+UseTLAB参数来设置（区域加锁机制）
  - 在Eden区给每个线程分配一块区域

### 4.初始化分配到的空间

给所有属性设置默认值，保证对象实例字段在不赋值可以直接使用

- 属性的默认

### 5.设置对象的对象头

将对象的所属类（即类的元数据信息）、对象的HashCode和对象的GC信息、锁信息等数据存储在对象的对象头中。这个过程的具体设置方式取决于JVM实现。

### 6.执行init方法进行初始化

在java程序的视角看来，初始化才正式开始。初始化成员变量，执行实例化代码块，调用类的构造器方法，并把堆内对象的首地址赋值给引用变量。

主要执行下面几个操作：

- 显示初始化
- 代码块中的初始化
- 构造器初始化

## 对象的内存布局

对象的布局包括：

- 对象头
- 实例数据
- 对齐填充

#### 对象头

对象头包含两个部分，分别是**运行时元数据**和**类型指针**（如果是数组还要记录数组的长度）

**运行时元数据**包括 **哈希值、GC分代年龄、锁状态标志、线程持有的锁、偏向线程id、偏向时间戳**

**类型指针**指向类元数据InstanceKlass，确定该对象所属的类型。指向的其实是方法区中存放的类元信息

#### 实例数据

![image-20210724163157790](https://gitee.com/aruul/a-ru-img/raw/master/img/20210724163159.png)

#### 对齐填充

不是必须的，也没有特别的含义，仅仅起到占位符的作用

#### 小结

```java
public class Customer{
    int id = 1001;
    String name;
    Account account;
    
    {
        name = "aRuul"
    }
    
    public Customer(){
        account = new Account();
	}
    
}
----------------------------------------------

public Account{
    
}

----------------------------------------------
public MyTest{
    public static void main(String[] args){
        Customer customer = new Customer();
    }
}
```

![image-20210724164202328](https://gitee.com/aruul/a-ru-img/raw/master/img/20210724164203.png)

​																										【纠错】方法区里的Klass改成Class

# 直接内存

这里先略过【p106】

# 执行引擎

这里也先略过

# String Table

## 基本特性

- String 字符串，使用一对""

- String声明是final的，不可被继承

- String实现了Serializable接口：表示字符串是支持序列化的。实现了Comparable接口：表示string可以比较大小

- string在jdk8及以前内部定义了final **char[] value**用于存储字符串数据。JDK9时改为**byte[] value** 

- String 代表不可变的字串序列

  - 当对字符串重新赋值时，需要重写指定内存区域赋值，不能使用原有的value进行赋值。 
  - 当对现有的字符串进行连接操作时，也需要重新指定内存区域赋值，不能使用原有的value进行赋值。
  - 当调用string的replace（）方法修改指定字符或字符串时，也需要重新指定内存区域赋值，不能使用原有的value进行赋值。 
  - 通过字面量的方式（区别于new）给一个字符串赋值，此时的字符串值声明在字符串常量池中。

  ```java
  class Demo{
      public static void test1() {
          // 字面量定义的方式，“abc”存储在字符串常量池中
          String s1 = "abc";
          String s2 = "abc";
          System.out.println(s1 == s2);  //true
          s1 = "hello";
          System.out.println(s1 == s2);  //false
          System.out.println(s1);		//hello
          System.out.println(s2);		//abc
          System.out.println("----------------");
      }
  
      public static void test2() {
          String s1 = "abc";
          String s2 = "abc";
          // 只要进行了修改，就会重新创建一个对象，这就是不可变性
          s2 += "def";
          System.out.println(s1);  //abc
          System.out.println(s2);  //abcdef
          System.out.println("----------------");
      }
  
      public static void test3() {
          String s1 = "abc";
          String s2 = s1.replace('a', 'm');
          System.out.println(s1);  //abc
          System.out.println(s2);  //mbc
      }
  }
  ```

- 字符串常量池中是不会存储相同内容的字符串的。

  > String的string Pool是一个固定大小的Hashtable，默认值大小长度是1009。如果放进string Pool的string非常多，就会造成Hash冲突严重，从而导致链表会很长，而链表长了后直接会造成的影响就是当调用string.intern时性能会大幅下降。
  >
  > 使用-XX:StringTablesize可设置stringTable的长度
  >
  > 在jdk6中StringTable是固定的，就是1009的长度，所以如果常量池中的字符串过多就会导致效率下降很快。StringTableSize设置没有要求
  >
  > 在jdk7中，stringTable的长度默认值是60013，
  >
  > 在JDK8中，StringTable可以设置的最小值为1009

## String的内存分配

在Java语言中有8种基本数据类型和一种比较特殊的类型String。这些类型为了使它们在运行过程中速度更快、更节省内存，都提供了一种**常量池**的概念。

常量池就类似一个Java系统级别提供的缓存。8种基本数据类型的常量池都是系统协调的，string类型的常量池比较特殊。它的主要使用方法有两种。

- 直接使用双引号声明出来的String对象会直接存储在常量池中。比如：string info="aRuul"；
- 如果不是用双引号声明的string对象，可以使用String提供的intern()方法。

> Java 6及以前，字符串常量池存放在永久代
>
> Java 7中 oracle的工程师对字符串池的逻辑做了很大的改变，即**将字符串常量池的位置调整到Java堆内**
>
> 所有的字符串都保存在堆（Heap）中，和其他普通对象一样，这样可以让你在进行调优应用时仅需要调整堆大小就可以了。
>
> 字符串常量池概念原本使用得比较多，但是这个改动使得我们有足够的理由让我们重新考虑在Java 7中使用String.intern()。
>
> Java8元空间，字符串常量在堆
>
> 详情请看 上面**方法区-------方法区的演进**这一小节

### 为什么StringTable从永久代调整到堆中

- 永久代的默认比较小
- 永久代垃圾回收频率低

## 字符串拼接

1. 常量与常量的拼接结果在常量池，原理是编译器优化
2. 常量池中不会存在相同内容的常量
3. 只要其中有一个是变量，结果就在堆中(指的是堆中非字符串常量池的区域)。
4. 变量拼接的原理是StringBuilder
5. 如果拼接的结果调用intern()方法，则主动将常量池中还没有的字符串对象放入池中，并返回此对象的地址。

```java
public static void test1() {
    String s1 = "a" + "b" + "c";  // 得到 abc的常量池
    String s2 = "abc"; // abc存放在常量池，直接将常量池的地址返回
    /**
     * 最终java编译成.class，再执行.class
     */
    System.out.println(s1 == s2); // true，因为存放在字符串常量池
    System.out.println(s1.equals(s2)); // true
}

public static void test2() {
    String s1 = "javaEE";
    String s2 = "hadoop";
    String s3 = "javaEEhadoop";
    String s4 = "javaEE" + "hadoop";    
    String s5 = s1 + "hadoop";
    String s6 = "javaEE" + s2;
    String s7 = s1 + s2;
	//只要其中有一个是变量，结果就在堆中(指的是堆中非字符串常量池的区域),就是在堆中new一个。
    System.out.println(s3 == s4); // true
    System.out.println(s3 == s5); // false
    System.out.println(s3 == s6); // false
    System.out.println(s3 == s7); // false
    System.out.println(s5 == s6); // false
    System.out.println(s5 == s7); // false
    System.out.println(s6 == s7); // false
	//如果拼接的结果调用intern()方法，则主动将常量池中还没有的字符串对象放入池中，并返回此对象的地址。
    String s8 = s6.intern();
    System.out.println(s3 == s8); // true
}

public static void test4(){
    final String s1 = "a";  //注意！这里的话就算常量
    final String s2 = "b";  //注意！这里的话就算常量
    String s3 = "ab";
    String s4 = s1 + s2;
    System.out,println(s3==s4); //true
}
```

### 字符串拼接底层细节

```java
public void test3(){
	String s1 = "a";
    String s2 = "b";
    String s3 = "ab";
    String s4 = s1 + s2;
    System.out,println(s3==s4); //false
}
```

当执行`String s4 = s1 + s2;`时，

**底层实际上是新建了一个StringBuilder,然后将两个值进行拼接，细节如下：**

1. **StringBuilder temp = new StringBuilder();**   【补充：在jdk5.0之前用的是StringBuffer】
2. **temp.append("a");**
3. **temp.append("b");**
4. **temp.toString();     //toString()方法约等于 new String("ab")**

> String字符串拼接效率
>
> - 通过StringBuilder的append()方式添加字符串的效率，要远远高于String的字符串拼接方法
>
> 
>
>   StringBuilder好处如下
>
> - StringBuilder的append的方式，自始至终只创建一个StringBuilder的对象
> - 对于字符串拼接的方式，还需要创建很多StringBuilder对象和 调用toString时候创建的String对象
> - 内存中由于创建了较多的StringBuilder和String对象，内存占用过大，如果进行GC那么将会耗费更多的时间

## intern()的使用

**如果不是用双引号声明的string对象，可以使用string提供的intern方法：intern方法会从字符串常量池中查询当前字符串是否存在，若不存在就会将当前字符串放入常量池中。**

比如：

```java
String myInfo = new string("abc").intern();
```

也就是说，如果在任意字符串上调用string.intern方法，那么其返回结果所指向的那个类实例，必须和直接以常量形式出现的字符串实例完全相同。因此，下列表达式的值必定是true

```java
（"a"+"b"+"c"）.intern（）=="abc"
```

通俗点讲，Interned string就是确保字符串在内存里只有一份拷贝，这样可以节约内存空间，加快字符串操作任务的执行速度。注意，这个值会被存放在字符串内部池（String Intern Pool）

###  new String("ab")会创建几个对象

   两个

- 一个是new String()，会在堆空间创建
- 一个是"ab"，存放在字符串常量池中的对象

### new String("a") + new String("b") 会创建几个对象

```java
public class StringNewTest {    public static void main(String[] args) {        String str = new String("a") + new String("b");    }}---------------------字节码文件如下---------------------------------- 0 new #2 <java/lang/StringBuilder> 3 dup 4 invokespecial #3 <java/lang/StringBuilder.<init>> 7 new #4 <java/lang/String>10 dup11 ldc #5 <a>13 invokespecial #6 <java/lang/String.<init>>16 invokevirtual #7 <java/lang/StringBuilder.append>19 new #4 <java/lang/String>22 dup23 ldc #8 <b>25 invokespecial #6 <java/lang/String.<init>>28 invokevirtual #7 <java/lang/StringBuilder.append>31 invokevirtual #9 <java/lang/StringBuilder.toString>34 astore_135 return
```

​	六个

- 对象1：new StringBuilder()

- 对象2：new String("a")

- 对象3：常量池的 a

- 对象4：new String("b")

- 对象5：常量池的 b

- 对象6：StringBuilder调用toString()方法，

  toString中会创建一个 new String("ab")

  【注意】**调用toString方法，不会在常量池中生成"ab"**

  ```java
  	//StringBuilder中的toString()方法	@Override    public String toString() {        return new String(value, 0, count);     //这个方法并不会在常量池中生成字符串    }
  ```

### 面试题【难】

```java
package top.aruul;/** * @author aRu * @date 2021/7/17 17:56 */public class Demo {    public static void main(String[] args) {        String s= new String("1"); //堆中生成new String对象，字符串常量池中生成 "1"        s.intern();        //这里并没有赋值给其他字符串        String ss = s.intern();        String s2 = "1";        System.out.println(s==s2);  //false        System.out.println(ss==s);  //false        System.out.println(ss==s2); //true        /* s3记录的变量地址为 new String("11")         *执行完下面这行代码后，常量池中并没有 "11" */        String s3 = new String("1") + new String("1");        //【注意】这里的话常量池中并没有 "11",        // 所以执行下面的intern方法的时候，会在字符串常量池中生成"11"        //对于jdk6来说，会直接创建一个 "11" 在字符串常量池中        //对于jdk7/jdk8 来说，把字符串常量池移到了堆中，而上一行代码在堆中创建了一个对象：【new String("11")】        //为了节省空间，此时，字符串常量池中会创建一个指向【堆中 new String("11")】的地址        s3.intern();        //所以这里创建的 s4指向了字符串常量池中的 {一个指向【堆中 new String("11")】的地址}        String s4 = "11";        //所以这里对于jdk6：false        //对于jdk7/jdk8: true        System.out.println(s3==s4);    }}
```

### 面试题的拓展

```java
/* s3记录的变量地址为 new String("11")         *执行完下面这行代码后，常量池中并没有 "11" */String s3 = new String("1") + new String("1");String s4 = "11";  //在字符串常量池中生成对象 "11"s3.intern();     //这个操作没啥用，因为字符串常量池中已经有 "11"了，而且并没把结果返回给任何对象System.out.println(s3==s4);  //jdk8: false
```

---

```java
String s = new String("a") + new String("b");  //相当于在堆中new String("ab")String s2 = s.intern(); //在字符串常量池中生成一个指向堆中new String("ab")的地址，并返回给s2//以下结果均在jdk8中//"ab"在字符串常量池中是一个指向new String("ab")的地址，所以和s、s2是同一个东西System.out.println(s=="ab");    //trueSystem.out.println(s2=="ab");	//true
```

---

```java
String x = "ab";String s = new String("a") + new String("b");String s2 = s.intern();//以下结果均在jdk8中System.out.println(s2==x);  //trueSystem.out.println(s==x);   //false
```

### 小总结

总结String的intern()的使用：

JDK1.6中，将这个字符串对象尝试放入串池。

- 如果串池中有，则并不会放入。返回已有的串池中的对象的地址
- 如果没有，会把此**对象复制一份**，放入串池，并返回串池中的对象地址

JDK1.7起，将这个字符串对象尝试放入串池。

- 如果串池中有，则并不会放入。返回已有的串池中的对象的地址
- 如果没有，则会把**对象的引用地址**复制一份，放入串池，并返回串池中的引用地址

##  G1中的String去重操作

**注意这里说的重复，指的是在堆中的数据，而不是常量池中的，因为常量池中的本身就不会重复**

> 许多大规模的Java应用的瓶颈在于内存，测试表明，在这些类型的应用里面，Java堆中存活的数据集合差不多25%是string对象。更进一步，这里面差不多一半string对象是重复的，重复的意思是说： stringl.equals（string2）= true。堆上存在重复的string对象必然是一种内存的浪费。



 **G1中的String去重操作:**

- 当垃圾收集器工作的时候，会访问堆上存活的对象。**对每一个访问的对象都会检查是否是候选的要去重的String对象**。
- 如果是，把这个对象的一个引用插入到队列中等待后续的处理。一个去重的线程在后台运行，处理这个队列。处理队列的一个元素意味着从队列删除这个元素，然后尝试去重它引用的string对象。
- 使用一个hashtable来记录所有的被string对象使用的不重复的char数组。当去重的时候，会查这个hashtable，来看堆上是否已经存在一个一模一样的char数组。
- 如果存在，String对象会被调整引用那个数组，释放对原来的数组的引用，最终会被垃圾收集器回收掉。
- 如果查找失败，char数组会被插入到hashtable，这样以后的时候就可以共享这个数组了。

# 垃圾回收

## 概述

### 什么是垃圾？

垃圾是指**在运行程序中没有任何指针指向的对象**，这个对象就是需要被回收的垃圾。

### 为什么需要GC？

对于高级语言来说，一个基本认知是如果不进行垃圾回收，内存迟早都会被消耗完，因为不断地分配内存空间而不进行回收，就好像不停地生产生活垃圾而从来不打扫一样。

除了释放没用的对象，垃圾回收也可以清除内存里的记录碎片。碎片整理将所占用的堆内存移到堆的一端，以便JVM将整理出的内存分配给新的对象。

随着应用程序所应付的业务越来越庞大、复杂，用户越来越多，没有GC就不能保证应用程序的正常进行。而经常造成STW的GC又跟不上实际的需求，所以才会不断地尝试对GC进行优化。

### GC主要关注区域

GC主要关注于**方法区**和**堆**的垃圾回收

垃圾收集器可以对年轻代进行回收，也可以对老年代进行回收，甚至是全栈和方法区的回收。

其中，**java堆是垃圾收集器的工作重点。**



从次数上讲：

- **频繁回收Young区**
- **较少回收Old区**
- **基本不收集元空间**

## 标记阶段

在堆里面放存着几乎所有的java对象实例，在GC执行垃圾回收之前，**首先需要区分出内存中哪些是存活对象，哪些是已经死亡的对象**。只有被标记为已经死亡的对象，GC才会在执行垃圾回收时，释放掉其所占的内存空间，因此这个过程成为**垃圾标记阶段**。

**当一个对象已经不再被任何的存活对象继续引用时，就可以宣判为已经死亡。**

判断对象存活一般有两种方式：**引用计数算法**和**可达性分析算法**。

### 引用计数算法

引用计数算法（Reference Counting）比较简单，对每个对象保存一个整型的引用计数器属性。用于记录对象被引用的情况。

对于一个对象A，只要有任何一个对象引用了A，则A的引用计数器就加1；当引用失效时，引用计数器就减1。只要对象A的引用计数器的值为0，即表示对象A不可能再被使用，可进行回收。

优点：**实现简单，垃圾对象便于辨识；判定效率高，回收没有延迟性。**

缺点：

- 它需要单独的字段存储计数器，这样的做法增加了存储空间的开销
- 每次赋值都需要更新计数器，伴随着加法和减法操作，这增加了时间开销。 
- 引用计数器有一个严重的问题，即**无法处理循环引用的情况**。这是一条致命缺陷，导致**在Java的垃圾回收器中没有使用这类算法**

### **可达性分析算法**

> 可达性分析算法：也被称为 **根搜索算法、追踪性垃圾收集**

可达性分析算法基本思路：

- 可达性分析算法是以**根对象集合（GC  Roots）**为起始点，按照从上至下的方式搜索被根对象集合所连接的目标对象是否可达。

  > "GCRoots”根集合就是一组必须活跃的引用

- 使用可达性分析算法后，内存中的存活对象都会被根对象集合直接或间接连接着，搜索所走过的路径称为**引用链（Reference** Chain）

- 如果目标对象没有任何引用链相连，则是不可达的，就意味着该对象己经死亡，可以标记为垃圾对象。

- 在可达性分析算法中，只有能够被根对象集合直接或者间接连接的对象才是存活对象。

<img src="https://gitee.com/aruul/a-ru-img/raw/master/img/20210727150458.png" alt="image-20210727150457501" style="zoom:80%;" />

#### GC Roots可以是哪些？

- 虚拟机栈中引用的对象
  - 比如：各个线程被调用的方法中使用到的参数、局部变量等。
- 本地方法栈内JNI（通常说的本地方法）引用的对象方法区中**类静态属性**引用的对象
  - 比如：Java类的引用类型静态变量
- 方法区中常量引用的对象
  - 比如：字符串常量池（String Table）里的引用
- 所有被同步锁synchronized持有的对象
- Java虚拟机内部的引用。
  - 基本数据类型对应的Class对象，一些常驻的异常对象（如：Nu11PointerException、outofMemoryError），系统类加载器。
- 反映java虚拟机内部情况的JMXBean、JVMTI中注册的回调、本地代码缓存等。

【小总结】由于Root采用栈方式存放变量和指针，所以如果一个指针，它保存了堆内存里面的对象，但是自己又不存放在堆内存里面，那它就是一个Root。

【注意】如果要使用可达性分析算法来判断内存是否可回收，那么分析工作必须在一个能保障一致性的快照中进行。这点不满足的话分析结果的准确性就无法保证。

这点也是导致GC进行时必须“Stop The World”的一个重要原因。

即使是号称（几乎）不会发生停顿的CMS收集器中，枚举根节点时也是必须要停顿的。

## 对象的finalization机制

- java提供了对象终止机制来允许开发人员提供对象被销毁之前的自定义处理逻辑。

- 在垃圾回收此对象之前，总会先调用这个对象的finalize方法。

- finalize()方法允许在子类中被重写，**用于在对象被回收前进行资源释放**。**通常在这个方法中进行一些资源释放和清理工作，比如关闭文件、套接字和数据库链接等**



【注意】由于finalize()方法的存在，虚拟机中的**对象一般处于三种可能的状态。**

- 可触及的：从根节点开始，可以到达这个对象。

- 可复活的：对象的所有引用都被释放，但是对象有可能在finalize()中复活。

- 不可触及的：对象的finalize()被调用，并且没有复活，那么就会进入不可触及状态。

  ​						不可触及的对象不可能被复活，因为**finalize()只会被调用一次**。

判定一个对象objA是否可回收，至少要经过两次标记过程：

1. 如果对象objA到GC Roots没有引用链接，则进行第一次标记

2. 进行筛选，判断此对象是否有必要执行finalize()方法

   ① 如果对象objA没有重写finalize方法，或者finalize()方法已经被虚拟机调用过，则虚拟机视为“没有必要执行”，objA被判定为**不可触及的。**

   ② 如果对象objA重写了finalize()方法，且还未执行过，那么objA会被插入到F-Queue队列中，由一个虚拟机自动创建的、低优先级的Finalizer线程触发其finalize()方法执行。

   ③ finalize()方法是对象逃脱死亡的最后机会，稍后GC会对F-Queue队列中的对象进行第二次标记。**如果objA在finalize()方法中与引用链上的任何一个对象建立了联系，那么在第二次标记时，objA会被移出“即将回收”集合**。之后，对象会再次出现没有引用存在的情况。在这个情况下，finalize()方法不会被再次调用，对象会直接变成不可触及的状态，也就是说，**一个对象的finalize()方法只会被调用一次。**

## 清除阶段

当成功区分出内存中存活对象和死亡对象后，GC接下来的任务就是执行垃圾回收，释放掉无用对象所占用的内存空间，以便有足够的可用内存空间为新对象分配内存。

目前在JVM中比较常见的**三种垃圾收集算法**：

- **标记--清除算法(Mark-Sweep)**
- **复制算法(Copying)**
- **标记--压缩算法(Mark-Compact)**

### 标记--清除算法(Mark-Sweep)

**过程：**

- **标记**：Collector从根节点开始遍历，**标记所有被引用的对象**(**标记的是可达的对象，并不是标记的垃圾**)。一般是在对象Header中记录为可达对象

- **清除**：Collector对堆内存从头到尾进行线性的遍历(就是把所有的遍历一遍)，如果发现某个对象在其Header中没有被标记为可达对象，则将其回收。

  > 这里所谓的清除并不是真的置空，而是把需要清除的对象地址保存在空闲的地址列表里。下次有新对象需要加载时，判断垃圾的位置空间是否够，如果够，就存放覆盖原有的地址。

**缺点：**

- 标记清除算法的效率不算高，需要两次
- 在进行GC的时候，需要停止整个应用程序，用户体验较差
- 这种方式清理出来的空闲内存是不连续的，产生内碎片，需要维护一个空闲列表

### 复制算法(Copying)

**过程：**

将活着的内存空间分为两块，每次只使用其中一块，在垃圾回收时将正在使用的内存中的存活对象复制到未被使用的内存块中，之后清除正在使用的内存块中的所有对象，交换两个内存的角色，最后完成垃圾回收

<img src="https://gitee.com/aruul/a-ru-img/raw/master/img/20210727171423.png" alt="image-20210727171422045" style="zoom:80%;" />

把可达的对象，直接复制到另外一个区域中复制完成后，A区就没有用了，里面的对象可以直接清除掉，其实里面的新生代里面就用到了复制算法

**这个复制算法和年轻代中Minor GC时S0、S1中垃圾回收类似**

**优点：**

- 没有标记和清除过程，实现简单，运行高效
- 复制过去以后保证空间的连续性，不会出现“碎片”问题。

**缺点：**

- 此算法的缺点也是很明显的，就是需要两倍的内存空间。
- 对于G1(JDK默认垃圾回收器)这种分拆成为大量region的GC，复制而不是移动，意味着GC需要维护region之间对象引用关系，不管是内存占用或者时间开销也不小

**注意：**

**如果系统中的垃圾比较少，那么复制算法每次都要复制大量的存活对象，效率就会很低**。

所以理想的情况是，垃圾多，存活对象少，那么每次复制的存活对象就少，所以在新生代，对常规应用的垃圾回收，一次通常可以回收70%-99%的内存空间，回收的性价比较高，所以很多商业的虚拟机都是应用这种收集算法**回收新生代**。

### **标记--压缩算法(Mark-Compact)**

又称**标记整理算法**

> 复制算法的高效性是建立在存活对象少、垃圾对象多的前提下的。这种情况在新生代经常发生，但是在老年代，更常见的情况是大部分对象都是存活对象。如果依然使用复制算法，由于存活对象较多，复制的成本也将很高。因此，基于老年代垃圾回收的特性，需要使用其他的算法。

**过程：**

- 第一阶段和标记清除算法一样，从根节点开始标记所有被引用对象

- 第二阶段将所有的存活对象压缩到内存的一端，按顺序排放。之后，清理边界外所有的空间。

**优点**

- 消除了标记-清除算法当中，内存区域分散的缺点，我们需要给新对象分配内存时，JVM只需要持有一个内存的起始地址即可。
- 消除了复制算法当中，内存减半的高额代价。

**缺点**

- 从效率上来说，标记-整理算法要低于复制算法。
- 移动对象的同时，如果对象被其他对象引用，则还需要调整引用的地址
- 移动过程中，需要全程暂停用户应用程序。即：STW(Stop The World)

### 小结

|              | 标记清除           | 标记整理         | 复制                                  |
| ------------ | ------------------ | ---------------- | ------------------------------------- |
| **速率**     | 中等               | 最慢             | 最快                                  |
| **空间开销** | 少（但会堆积碎片） | 少（不堆积碎片） | 通常需要活对象的2倍空间（不堆积碎片） |
| **移动对象** | 否                 | 是               | 是                                    |

### 分代收集算法

> 分代收集算法，是基于这样一个事实：不同的对象的生命周期是不一样的。因此，不同生命周期的对象可以采取不同的收集方式，以便提高回收效率。一般是把Java堆分为新生代和老年代，这样就可以根据各个年代的特点使用不同的回收算法，以提高垃圾回收的效率。

在HotSpot中，基于分代的概念，GC所使用的内存回收算法必须结合年轻代和老年代各自的特点。

**年轻代（Young Gen）**：

年轻代特点：区域相对老年代较小，对象生命周期短、存活率低，回收频繁。

这种情况复制算法的回收整理，速度是最快的。复制算法的效率只和当前存活对象大小有关，因此很适用于年轻代的回收。而复制算法内存利用率不高的问题，通过hotspot中的两个survivor的设计得到缓解。

**老年代（Tenured Gen）**

老年代特点：区域较大，对象生命周期长、存活率高，回收不及年轻代频繁。

这种情况存在大量存活率高的对象，复制算法明显变得不合适。一般是由**标记-清除**或者是**标记-清除与标记-整理**的混合实现。

- Mark(标记)阶段的开销与存活对象的数量成正比。
- Sweep(清除)阶段的开销与所管理区域的大小成正相关。
- compact(压缩/整理)阶段的开销与存活对象的数据成正比。

以HotSpot中的CMS回收器为例子，CMS是基于Mark-Sweep实现的，对于对象的回收效率很高。而对于碎片化问题，CMS采用基于Mark-Compact算法的Serial Old回收器作为补偿措施；当内存回收不佳，将采用Serial Old执行Full GC以达到对老年代内存的整理。

### 增量收集算法

> 上述现有的算法，在垃圾回收过程中，应用软件将处于一种stop the World的状态。在stop the World状态下，应用程序所有的线程都会挂起，暂停一切正常的工作，等待垃圾回收的完成。如果垃圾回收时间过长，应用程序会被挂起很久，将严重影响用户体验或者系统的稳定性。为了解决这个问题，即对实时垃圾收集算法的研究直接导致了增量收集（Incremental Collecting）算法的诞生。

如果一次性将所有的垃圾进行处理，需要造成系统长时间的停顿，那么就可以让垃圾收集线程和应用程序线程交替执行。每次，垃圾收集线程只收集一小片区域的内存空间，接着切换到应用程序线程。依次反复，直到垃圾收集完成。

总的来说，**增量收集算法的基础仍是传统的标记-清除和复制算法。增量收集算法通过对线程间冲突的妥善处理**，允许垃圾收集线程以分阶段的方式完成标记、清理或复制工作

**缺点：**

使用这种方式，由于在垃圾回收过程中，间断性地还执行了应用程序代码，所以能减少系统的停顿时间。但是，因为线程切换和上下文转换的消耗，会使得垃圾回收的总体成本上升，造成系统吞吐量的下降。

### 分区算法

一般来说，在相同条件下，堆空间越大，一次GC时所需要的时间就越长，有关GC产生的停顿也越长。

为了更好地控制GC产生的停顿时间，将一块大的内存区域分割成多个小块，根据目标的停顿时间，每次合理地回收若干个小区间，而不是整个堆空间，从而减少一次GC所产生的停顿。

分代算法将按照对象的生命周期长短划分成两个部分，**分区算法将整个堆空间划分成连续的不同小区间**。 每一个小区间都独立使用，独立回收。这种算法的好处是可以控制一次回收多少个小区间。

# 垃圾回收相关概念(加餐)

## System.gc()的理解

默认情况下，通过System.gc()或者Runtime.getRuntime().gc()的调用，会显示触发Full GC，同时对老年代和新生代进行回收，尝试释放被丢弃对象占用的空间。

但是System.gc()无法保证对垃圾收集器的调用

【未完待续...】

# 垃圾回收器

## GC分类

### 按线程数

按照线程分，可以分为**串行垃圾回收器**和**并行垃圾回收器**

#### 串行垃圾回收器

指的是再同一时间内只允许有一个cpu用于执行垃圾回收操作。此时工作线程被暂停，直至垃圾收集工作结束。

- 在诸如单CPU处理器或者较小的应用内存等硬件平台不是特别优越的场合，串行回收器的性能表现可以超过并行回收器和并发回收器。所以，串行回收默认被应用在客户端的Client模式下的JVM中
- 在并发能力比较强的CPU上，并行回收器产生的停顿时间要短于串行回收器。

#### 并行垃圾回收器

和串行回收相反，并行收集可以运用多个CPU同时执行垃圾回收，因此提升了应用的吞吐量，不过并行回收仍然与串行回收一样，采用独占式，使用了“stop-the-world”机制。

### 按工作模式

按照工作模式分，可以分为**并发式垃圾回收器**和**独占式垃圾回收器**。

- **并发式垃圾回收器与应用程序线程交替工作，以尽可能的减少应用程序的停顿时间**
- **独占式垃圾回收器一旦运行，就停止应用程序中所有的用户线程，直到垃圾回收过程完全结束**

### 按碎片处理方式分

按碎片处理方式分，可分为**压缩式垃圾回收器**和**非压缩式垃圾回收器**。

- 压缩式垃圾回收器会在回收完成后，对存活对象进行压缩整理，消除回收后的碎片。
- 非压缩式的垃圾回收器不进行这步操作。



按工作的**内存区间**分，又可分为**年轻代垃圾回收器**和**老年代垃圾回收器**。

## 评估GC的性能指标

- **吞吐量**：运行用户代码的时间占总运行时间的比例（总运行时间 = 程序的运行时间 + 内存回收的时间）
- 垃圾收集开销：吞吐量的补数，垃圾收集所用时间与总运行时间的比例。
- **暂停时间**：执行垃圾收集时，程序的工作线程被暂停的时间。
- 收集频率：相对于应用程序的执行，收集操作发生的频率。
- **内存占用**：Java堆区所占的内存大小。
- 快速：一个对象从诞生到被回收所经历的时间。

**吞吐量、暂停时间、内存占用** 这三者共同构成一个“不可能三角”。三者总体的表现会随着技术进步而越来越好。

 简单来说，主要抓住两点：**吞吐量    暂停时间**

### 吞吐量

吞吐量就是cpu用于运行用户代码的时间与cpu总消耗时间的比值
$$
吞吐量 = 运行用户代码时间 / (运行用户代码时间+垃圾收集时间)
$$
这种情况下，**应用程序能容忍较高的暂停时间**，因此，高吞吐量的应用程序有更长的时间基准，快速响应是不必考虑的

**吞吐量优先**，意味着在单位时间内，**STW(Stop The World)的时间最短**

### 暂停时间

暂停时间是指一个时间段内应用程序线程暂停，让GC线程执行的状态。

暂停时间优先意味着尽可能让**单次的STW的时间最短**

![image-20210728161141936](https://gitee.com/aruul/a-ru-img/raw/master/img/20210728161143.png)

### 吞吐量VS暂停时间

高吞吐量较好因为这会让应用程序的最终用户感觉只有应用程序线程在做“生产性”工作。**直觉上，吞吐量越高程序运行越快。**

低暂停时间（低延迟）较好因为从最终用户的角度来看不管是GC还是其他原因导致一个应用被挂起始终是不好的。这取决于应用程序的类型，有时候甚至短暂的200毫秒暂停都可能打断终端用户体验。因此，**具有低的较大暂停时间是非常重要的，特别是对于一个交互式应用程序。**

**不幸的是”高吞吐量”和”低暂停时间”是一对相互竞争的目标（矛盾）。**

现在标准：**在最大吞吐量优先的情况下，降低停顿时间**

##  不同的垃圾回收器概述

### 七种经典垃圾回收器

- 串行回收器：Serial、Serial Old
- 并行回收器：ParNew、Parallel Scavenge、Parallel Old
- 并发回收器：CMS、G1 

---

按照**分代**，这7种垃圾回收器分类如下：

- 新生代收集器：Serial、ParNew、Parallel Scavenge
- 老年代收集器：Serial Old、Parallel Old、CMS
- 整堆收集器：G1

![image-20210728185810119](https://gitee.com/aruul/a-ru-img/raw/master/img/20210728185811.png)

### 圾收集器的组合关系

![image-20210729163011854](https://gitee.com/aruul/a-ru-img/raw/master/img/20210729163013.png)

- 两个收集器间有连线，表明它们可以搭配使用：Serial/Serial old、Serial/CMS、ParNew/Serial old、ParNew/CMS、Parallel Scavenge/Serial Old、Parallel Scavenge/Parallel 01d、G1；
- 其中Serial Old作为CMS出现"Concurrent Mode Failure"失败的后备预案。
- （红色虚线）由于维护和兼容性测试的成本，在JDK 8时将Serial+CMS、ParNew+Serial Old这两个组合声明为废弃（JEP173），并在JDK9中完全取消了这些组合的支持（JEP214），即：移除。
- （绿色虚线）JDK14中：弃用Parallel Scavenge和Serial Old GC组合（JEP366）
- （青色虚线）JDK14中：删除CMs垃圾回收器（JEP363）

### 查看默认垃圾收集器

> **-XX:+PrintCommandLineFlags**：查看命令行相关参数（包含使用的垃圾收集器）
>
> 使用命令行指令：jinfo -flag 相关垃圾回收器参数 进程ID

## Serial回收器：串行回收

**【关键词】串行	新生代	复制算法	client模式**  

- Serial收集器是最基本，历史最悠久的，是JDK1.3之前回收**新生代**的唯一选择。

- Serial收集器采用的是**复制算法**，**串行回收**和"**Stop The World**"机制的方式执行内存回收

- Serial收集器还提供了用于执行老年代垃圾收集的**Serial Old收集器**。

  **Serial Old收集器**同样也采用了**串行回收**和"**Stop The World**"机制，只不过内存回收算法采用的是**标记--压缩**算法

![image-20210729164632404](https://gitee.com/aruul/a-ru-img/raw/master/img/20210729164633.png)

【注意】这个收集器是个单线程的收集器，**“单线程”不仅是指的是它只会使用一个cpu或者一条收集线程来完成垃圾收集工作**，更重要的是它进行垃圾回收的时候，**必须暂停其他所有的工作线程(Stop The World)**，直到收集结束。

**优势：**

**简单而高效**(与其他收集器的单线程比)，对于限定单个cpu的环境来说，Serial收集器由于没有线程交互的开销，专心做垃圾收集自然可以获得最高的单线程收集效率。**运行在client模式下的虚拟机是个不错的选择。**

**应用场景：**

在用户的桌面应用场景中，可用内存一般不大（几十MB至一两百MB），可以在较短时间内完成垃圾收集（几十ms至一百多ms），只要不频繁发生，使用串行回收器是可以接受的。

**参数设置：**

在HotSpot虚拟机中，使用-XX：+UseSerialGC参数可以指定年轻代和老年代都使用串行收集器。

等价于新生代用Serial GC，且老年代用Serial old GC

## ParNew回收器：并行回收

**【关键词】并行	新生代	复制算法	Service模式**

> Par 是 Parallel的缩写  ， New：只能处理的是**新生代**

- ParNew收集器除了采用**并行回收**的方式执行垃圾回收外，与Serial回收器几乎没有任何区别。

- ParNew收集器在**年轻代**中同样也是采用**标记--复制算法**和“**Stop The World**”的机制

- ParNew 是很多JVM运行在**Service模式下新生代的默认垃圾收集器**
- 除Serial外，目前只有ParNew GC能与CMS收集器配合工作



![image-20210729170555163](https://gitee.com/aruul/a-ru-img/raw/master/img/20210729170556.png)

- **对于新生代，回收次数频繁，使用并行方式高效**

- **对于老年代，回收次数少，使用串行方式节省资源。**

**参数设置：**

在程序中，开发人员可以通过选项"-XX：+UseParNewGC"手动指定使用ParNew收集器执行内存回收任务。它表示年轻代使用并行收集器，不影响老年代。

-XX:ParallelGCThreads限制线程数量，默认开启和CPU数据相同的线程数。

## ParNew收集器在任何场景下都比Serial收集器效率高吗？

**ParNew收集器运行在多CPU**的环境下，由于可以充分利用多CPU、多核心等物理硬件资源优势，可以更快速地完成垃圾收集，提升程序
的吞吐量。
但是在**单个CPU的环境下**， **ParNew收集器不比 Serial收集器更高效**。虽然 Serial收集器是基于串行回收，但是由于CPU不需要频繁地做任务切换，因此可以有效避免多线程交互过程中产生的一些额外开销.

## Parallel Scavenge：吞吐量优先

**【关键词】并行	新生代	复制算法	吞吐量优先**

- HotSpot的年轻代除了拥有ParNew收集器是基于并行回收的以外，

- **Parallel Scavenge**收集器同样也采用了**复制算法、并行回收和“Stop The World”**



> **Parallel Scavenge和ParNew的区别？**
>
> - **Parallel Scavenge收集器的目标是达到一个可控制的吞吐量，它也被称为吞吐量优先的垃圾收集器。**
>
> - **自适应调节策略**也是Parallel Scavenge与ParNew的一个重要区别（自适应调节是指动态的调节内存分配情况）



- 高吞吐量则可以高效率地利用CPU时间，尽快完成程序的运算任务，主要**适合在后台运算而不需要太多交互的任务**。因此，常见在服务器环境中使用。例如，**那些执行批量处理、订单处理、工资支付、科学计算**的应用程序。

- Parallel Scavenge收集器在JDK1.6时提供了用于执行老年代垃圾收集的Parallel Old收集器，用来代替老年代的Serial Old收集器。
- **Parallel Old收集器**采用了**标记-压缩算法**，但同样也是基于**并行回收和"stop-the-World"**机制。

![image-20210729200414301](https://gitee.com/aruul/a-ru-img/raw/master/img/20210729200415.png)

- **在程序吞吐量优先的应用场景中，Paralle1收集器和Parallel Old收集器的组合，在server模式下的内存回收性能很不错。**

- **在Java8中，默认是此垃圾收集器。**



**参数设置：**

- -XX：+UseParallelGC 手动指定年轻代使用Parallel并行收集器执行内存回收任务。

- -XX：+UseParallelOldGC手动指定老年代都是使用并行回收收集器。
  - 分别适用于新生代和老年代。默认jdk8是开启的。
  - 上面两个参数，默认开启一个，另一个也会被开启。（互相激活）

- -XX:ParallelGCThreads设置年轻代并行收集器的线程数。一般地，最好与CPU数量相等，以避免过多的线程数影响垃圾收集性能。
  - 在默认情况下，当CPU数量小于8个，ParallelGCThreads的值等于CPU数量。
  - 当CPU数量大于8个，ParallelGCThreads的值等于3+[5*CPU_Count]/8]

- -XX:MaxGCPauseMillis 设置垃圾收集器最大停顿时间（即STw的时间）。单位是毫秒。
  - 为了尽可能地把停顿时间控制在MaxGCPauseMills以内，收集器在工作时会调整java堆大小或者其他一些参数。
  - 对于用户来讲，停顿时间越短体验越好。但是在服务器端，我们注重高并发，整体的吞吐量。所以服务器端适合Parallel，进行控制。
  - 该参数使用需谨慎。

- -XX:GCTimeRatio垃圾收集时间占总时间的比例（=1/（N+1））。用于衡量吞吐量的大小。
  - 取值范围（0，100）。默认值99，也就是垃圾回收时间不超过1%。
  - 与前一个-xx:MaxGCPauseMillis参数有一定矛盾性。暂停时间越长，Radio参数就容易超过设定的比例。

- -XX:+UseAdaptivesizepplicy 设置Parallel scavenge收集器具有自适应调节策略
  - 在这种模式下，年轻代的大小、Eden和Survivor的比例、晋升老年代的对象年龄等参数会被自动调整，已达到在堆大小、吞吐量和停顿时间之间的平衡点。
  - 在手动调优比较困难的场合，可以直接使用这种自适应的方式，仅指定虚拟机的最大堆、目标的吞吐量（GCTimeRatio）和停顿时间（MaxGCPauseMil1s），让虚拟机自己完成调优工作。

## CMS回收器：低延迟

**【关键词】并发	老年代	标记--清除算法	低延迟**

### 概述

- 在JDK1.5时期，Hotspot推出了一款在强交互应用中几乎可认为有划时代意义的垃圾收集器：**CMS（Concurrent-Mark-Sweep）**收集器，这款收集器是HotSpot虚拟机中第一款真正意义上的并发收集器，**它第一次实现了让垃圾收集线程与用户线程同时工作**。
- 低延迟
- CMS回收器采用了**标记--清除**算法，同时也会“Stop The World”
- 是**老年代**的垃圾回收器

### 工作过程

<img src="https://gitee.com/aruul/a-ru-img/raw/master/img/20210730144900.png" alt="image-20210730144859247" style="zoom:80%;" />

CMS整个过程主要分为四个阶段：初始标记、并发标记、重新标记、并发清除

- **初始标记阶段(Initial-Mark)**：这个阶段会“Stop The World”，主要任务是**仅仅标记出GC Roots能直接关联到的对象**，这里的**速度非常快**
- **并发标记阶段(Concurrent-Mark)**：从**GC Roots直接关联的对象开始对整个对象图遍历**，**费时较长**，但是不需要停顿用户线程，**与用户线程并发运行**
- **重新标记阶段(Remark)**：为了**修正并发标记期间，因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录**，停顿时间比初始标记时间长，比并发阶段短
- **并发清除阶段(Concurrent-Sweep)**：**清理删除标记阶段判断已经死亡的对象，释放内存空间**，这个阶段是和用户线程同时并发的



==**由于最耗时的并发标记和并发清除阶段都不需要暂停工作，所以整体上的回收是低停顿的。**==

> 由于在垃圾收集阶段用户线程没有中断，所以在CMS回收过程中，还**应该确保应用程序用户线程有足够的内存可用**。
>
> 因此，CMS收集器不能像其他收集器那样等到老年代几乎完全被填满了再进行收集，而是当堆内存使用率达到某一阈值时，便开始进行回收，以确保应用程序在CMS工作过程中依然有足够的空间支持应用程序运行。
>
> 要是CMS运行期间预留的内存无法满足程序需要，就会出现一次“**Concurrent Mode Failure” 失败**，这时虚拟机将**启动后备预案**：临时启用Serial old收集器来重新进行老年代的垃圾收集，这样停顿时间就很长了。
>
> CMS收集器的垃圾收集算法采用的是**标记清除算法**，这意味着每次执行完内存回收后，不可避免地将会产生一些内存碎片。那么CMS在为新对象分配内存空间时，只能够选择**空闲列表（Free List）执行内存分配**。

### CMS为什么不使用标记整理算法？

因为当并发清除的时候，用Compact整理内存的话，原来的用户线程使用的内存还怎么用呢？要保证用户线程能继续执行，前提的它运行的资源不受影响。Mark Compact更适合“Stop The World” 这种场景下使用。

### 优点

- 并发收集
- 低延迟

### 缺点

- 会**产生内存碎片**，导致并发清除后，用户线程可用的空间不足。在无法分配大对象的情况下，不得不提前触发FullGC。
- CMS收集器对CPU资源非常敏感。在并发阶段，它虽然不会导致用户停顿，但是会因为占用了一部分线程而导**致应用程序变慢**，**总吞吐量会降低。**
- **CMS收集器无法处理浮动垃圾。**可能出现“Concurrent Mode Failure"失败而导致另一次Full GC的产生。在并发标记阶段由于程序的工作线程和垃圾收集线程是同时运行或者交叉运行的，那么**在并发标记阶段如果产生新的垃圾对象，CMS将无法对这些垃圾对象进行标记**，最终会导致这些新产生的垃圾对象没有被及时回收，从而只能在下一次执行GC时释放这些之前未被回收的内存空间。

### 小结

- 如果想最小化的使用内存和并行开销，选Serial GC

- 如果想最大化应用程序吞吐量，选Parallel GC

- 如果想最小化GC的中断或停顿时间(也就是 低延迟)，选CMS GC

## G1回收器：区域化分代式

**G1 全称Garbage First**

**官方给G1设定的目标是在延迟可控的情况下获得尽可能高的吞吐量，所以才担当起“全功能收集器”的重任与期望**。

### 为什么名字叫 Garbage First(G1)呢？

- 因为G1是一个并行回收器，它把堆内存分割为很多不相关的区域（Region）（物理上不连续的）。使用不同的Region来表示Eden、幸存者0区，幸存者1区，老年代等。

- G1 GC有计划地避免在整个Java堆中进行全区域的垃圾收集。G1跟踪各个Region里面的垃圾堆积的价值大小（回收所获得的空间大小以及回收所需时间的经验值），在后台维护一个优先列表，**每次根据允许的收集时间，优先回收价值最大的Region**。

- 由于这种方式的侧重点在于回收垃圾最大量的区间（Region），所以我们给G1一个名字：垃圾优先（Garbage First）。

### 分区Region：化整为零

使用G1收集器时，它将整个**Java堆划分成约2048个大小相同的独立Region块**，每个Region块大小根据堆空间的实际大小而定，整体被控制在1MB到32MB之间，且为2的N次幂，即1MB，2MB，4MB，8MB，16MB，32MB。可以通过-XX:G1HeapRegionSize设定。**所有的Region大小相同，且在JVM生命周期内不会被改变。**

虽然还保留有新生代和老年代的概念，但新生代和老年代不再是物理隔离的了，它们都是一部分Region（不需要连续）的集合。通过Region的动态分配方式实现逻辑上的连续。

<img src="https://gitee.com/aruul/a-ru-img/raw/master/img/20210730163058.png" alt="image-20210730163057599" style="zoom:80%;" />

一个region有可能属于Eden，Survivor或者old。但是**一个region只可能属于一个角色**。

G1垃圾收集器还增加了一种新的内存区域，叫做Humongous内存区域，如图中的H块。主要用于存储大对象，如果超过1.5个region，就放到H。有些大对象可能生命周期没有那么长，放在老年代可能不会被及时回收，所以有了H区，用于存放一些生命周期短的大对象。

### 优点

**1.并行与并发**

- 并行性：G1在回收期间，可以有多个GC线程同时工作，有效利用多核计算能力。此时用户线程STW
- 并发性：G1拥有与应用程序交替执行的能力，部分工作可以和应用程序同时执行，因此，一般来说，不会在整个回收阶段发生完全阻塞应用程序的情况

**2.分代收集**

- 从分代上看，**G1依然属于分代型垃圾回收器**，它会区分年轻代和老年代，年轻代依然有Eden区和Survivor区。但从堆的结构上看，它不要求整个Eden区、年轻代或者老年代都是连续的，也不再坚持固定大小和固定数量。

- 将**堆空间分为若干个区域（Region），这些区域中包含了逻辑上的年轻代和老年代**。

  <img src="https://gitee.com/aruul/a-ru-img/raw/master/img/20210730161028.png" alt="image-20210730161026490" style="zoom:80%;" />

- 和之前的各类回收器不同，它**同时兼顾年轻代和老年代**。对比其他回收器，或者工作在年轻代，或者工作在老年代；

**3.空间整合**

- CMS：“标记-清除”算法、内存碎片、若干次GC后进行一次碎片整理
- G1将内存划分为一个个的region。内存的回收是以region作为基本单位的。**Region之间是复制算法**，但**整体上实际可看作是标记-压缩算法**，两种算法都可以**避免内存碎片**。这种特性有利于程序长时间运行，分配大对象时不会因为无法找到连续内存空间而提前触发下一次GC。尤其是当Java堆非常大的时候，G1的优势更加明显。

**4.可预测的停顿时间模型（即：软实时soft real-time）** 

这是G1相对于CMS的另一大优势，G1除了追求低停顿外，还能建立**可预测的停顿时间模型**，能让使用者明确指定在一个长度为M毫秒的时间片段内，消耗在垃圾收集上的时间不得超过N毫秒。

- 由于分区的原因，G1可以只选取部分区域进行内存回收，这样缩小了回收的范围，因此对于全局停顿情况的发生也能得到较好的控制。
- G1跟踪各个Region里面的垃圾堆积的价值大小（回收所获得的空间大小以及回收所需时间的经验值），在后台维护一个优先列表，**每次根据允许的收集时间，优先回收价值最大的Region**。保证了G1收集器在有限的时间内可以**获取尽可能高的收集效率**。
- 相比于CMS GC，G1未必能做到CMS在最好情况下的延时停顿，但是最差情况要好很多。

### 缺点

相较于CMS，G1还不具备全方位、压倒性优势。比如在用户程序运行过程中，G1无论是为了垃圾收集产生的内存占用（Footprint）还是程序运行时的**额外执行负载(要维护记忆集Remembered Set)**都要比CMS要高。

从经验上来说，在小内存应用上CMS的表现大概率会优于G1，而G1在大内存应用上则发挥其优势。平衡点在6-8GB之间。

### Remembered Set（记忆集）

**一个对象被不同区域引用的问题**

一个Region不可能是孤立的，一个Region中的对象可能被其他任意Region中对象引用，判断对象存活时，就需要扫描整个Java堆才能保证准确。这样的话在回收新生代时也不得不同时扫描老年代，这样的话会降低MinorGC的效率

**解决方法：**

无论G1还是其他分代收集器，JVM都是使用**Remembered Set**来避免全局扫描：

**每个Region都有一个对应的Remembered Set；**

每次Reference类型数据写操作时，都会产生一个Write Barrier(写屏障)暂时中断操作；

然后检查将要写入的引用指向的对象是否和该Reference类型数据在不同的Region（其他收集器：检查老年代对象是否引用了新生代对象）；

如果不同，通过CardTable把相关引用信息记录到引用指向对象的所在Region对应的Remembered Set中；

当进行垃圾收集时，在GC根节点的枚举范围加入Remembered Set；就可以保证不进行全局扫描，也不会有遗漏。

图示如下：

<img src="https://gitee.com/aruul/a-ru-img/raw/master/img/20210731151601.png" alt="image-20210731151559780" style="zoom:80%;" />

**说人话就是：相当于每个region都有一个表，记录了其他区指向本区对象的引用，这样的话不用扫描整个空间了**

### 回收过程

G1回收器垃圾回收主要包括三个环节：

1. **年轻代(Young GC)**
2. **老年代并发标记过程(Concurrent Marking)**
3. **混合回收(Mixed GC)**

(如果需要的，单线程、独占式、高强度的Full GC还是继续存在的。它针对GC的评估失败提供了一种失败保护机制，即强力回收)

<img src="https://gitee.com/aruul/a-ru-img/raw/master/img/20210731145139.png" alt="image-20210731145138691" style="zoom:80%;" />

**概述环节如下：**

1. 当**年轻代的Eden区用尽时**开始年轻代的回收过程，G1的年轻代回收是**并行的独占式**收集器。在收集期间，G1 GC暂**停所有的应用程序线程**，启动**多线程执行年轻代的回收**，从**年轻代区间移动存活对象到Survivor区间或者老年区间**，也有**可能两个区间都会涉及。**
2. 当堆内存使用达到一定值(默认45%)，开始老年代并发标记过程。
3. 标记完成之后马上开始混合回收过程。对于一个混合回收期，G1GC从老年区间移动存活对象到空闲区间，这些空闲区间也就成为了老年代的一部分。和年轻代不同，老年代的G1回收器和其他GC不同，**G1的老年代回收器不需要整个老年代被回收，一次只需要扫描/回收一小部分老年代的Region就可以了。同时，这个老年代Region是和年轻代一起被回收的。**

# 结束

这个课程陆陆续续的学了半个多月，很惭愧只了解到了jvm的一小点理论和皮毛。

希望这个笔记对你有用，如果觉得不错的话可以去点一个[star](https://github.com/aRuul/jvmStudy)。

希望我们都有光明的未来，共勉之！

