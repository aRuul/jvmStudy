# 概述

## java虚拟机JVM

java虚拟机是一台执行java字节码的虚拟计算机，它拥有独立的运行机制，其运行的java字节码也未必由java语言编译而成。

JVM平台的各种语言可以共享java虚拟机带来的跨平台性、优秀的垃圾回收机制以及可靠的即时编译器。java技术的核心就是java虚拟机（jvm，java virtual machine）

## JVM的位置

![image-20210716200357558](https://gitee.com/aruul/a-ru-img/raw/master/img/20210716200358.png)

jvm是运行在操作系统之上的，没有和硬件直接交互

## JVM的整体结构

![image-20210716200826280](https://gitee.com/aruul/a-ru-img/raw/master/img/20210716200827.png)

​															==要求会自己画出这张图==

- HotSport VM是目前市面上最高性能的虚拟机的代表作之一。
- 它采用解释器与即时编译器并存的架构

## java代码执行流程

比如我们现在写了一个 HelloWorld.java 好了，那这个 HelloWorld.java 抛开所有东西不谈，那是不是就类似于一个文本文件，只是这个文本文件它写的都是英文，而且有一定的缩进而已。

那我们的 **JVM** 是不认识文本文件的，所以它需要一个 **编译** ，让其成为一个它会读二进制文件的 **HelloWorld.class**

如果 **JVM** 想要执行这个 **.class** 文件，我们需要将其装进一个 **类加载器** 中，它就像一个搬运工一样，会把所有的 **.class** 文件全部搬进JVM里面来。

![image-20210716200204379](https://gitee.com/aruul/a-ru-img/raw/master/img/20210716200206.png)

==由于跨平台的设计，java的指令都是根据栈来设计的。==跨平台性，指令集小，指令多。

相对于基于寄存器的架构，基于栈的架构的执行性能相比寄存器来说要差一些

## JVM的生命周期

**java虚拟机的启动**是通过引导类类(bootstrap class loader)创建一个初始化类(initial class)来完成，这个类是有虚拟机的具体实现指定的。

**虚拟机的执行:** 一个运行中的Java虚拟机有着一个清晰的任务：执行Java程序
程序开始执行时他才运行，程序结束时他就停止
执行一个所谓的Java程序的时候，真真正正在执行的是一个叫做Java虚拟机的进程

**虚拟机的退出**
有如下的几种情况：

- 程序正常执行结束
- 程序在执行过程中遇到了异常或错误而异常终止
- 由于操作系统出现错误而异致Java虚拟机进程终止
- 某线程调用 Runtime类或 system类的exit方法，或 Runtime类的halt
  方法，并且Java安全管理器也允许这次exit或halt操作
- 除此之外，JNI( Java Native Interface)规范描述了用JNI Invocation APｴ来加载或卸载Java虚拟机时，Java虚拟机的退出情况

## HotSpot虚拟机

不管是JDK6还是最常用的JDK8，默认虚拟机都是HotSpot

> 名称中的 Hotspot指的就是它的热点代码探测技术。
> 通过计数器找到最具编译价值代码，触发即时编译或上替拧
> 通过编译器与解释器协同工作，在最优化的程序响应时间与最佳执行性能中取得平衡

---

Graal VM  ---"Run Programs Faster Anywhere"  最有可能替代HotSpot。

# 类加载子系统

![image-20210717153811503](https://gitee.com/aruul/a-ru-img/raw/master/img/20210717153813.png)

**加载--> 链接--> 初始化**

**如果自己手写一个java虚拟机的话，主要考虑哪些结构？  类加载器和执行引擎**

## 类的加载过程

![image-20210717154600485](https://gitee.com/aruul/a-ru-img/raw/master/img/20210717154605.png)

- 类加载子系统负责从文件系统或者网络系统中加载Class文件，class文件在文件开头有特定的文件标识
- ClassLoader只负责class文件的加载，至于它是否可以运行，则是由Execution Engine来jued
- 加载的**类信息存放在一块成为方法区**的内存空间。
- 除了类的信息之外，**方法区还会存放运行时的常量池信息**，可能还包括**字符串常量和数字常量**（这部分常量信息是Class文件中常量池部分的内存映射）

---

具体的类加载过程图

![image-20210717160035120](https://gitee.com/aruul/a-ru-img/raw/master/img/20210717160036.png)

### 第一步 加载 --生成 java.lang.Class对象

1. 通过一个类的全限定名获取此类的二进制字节流
2. 将这个字节流所代表的静态数据结构转化为方法区的运行时数据结构
3. 在内存中**生成**一个代码这个类的  **java.lang.Class对象**，作为方法区这个类的各种数据的访问入口

### 第二步 链接

#### 1.**验证( Verify):**

- 目的在于确保class文件的字节流中包含信息符合当前虚拟机要求，保证被加载类的正确性，不会危害虚拟机自身安全。
- 主要包括四种验证，文件格式验证，元数据验证，字节码验证，符号引用验证

> java .class文件开头是COFFBABE

#### 2.**准备( Prepare):**

- 为**类变量**分配内存并且设置该类变量的**默认初始值**，即零值。

  ```java
  class Demo{
      //这时a会被赋值为0，在初始化时才会被初始化为1
      private static int a = 1;
  }
  ```

- 这里**不包含用final修饰的 static**,因为**final在编译的时候就会分配了**，准备阶段会显式初始化

- 这里不会为实例变量分配初始化，类变量会分配在方法区中，而**实例变量**是会随着对象一起分
  配到**java堆**中。

#### 3.**解析( Resolve)**

- 将常量池内的符号引用转换为直接引用的过程
- 事实上，解析操作住住会伴随着JVM在执行完初始化之后再执行。
- 符号引用就是一组符号来描述所引用的目标。符号引用的字面量形式明确定义在《java虚拟机规范》的Class文件格式中。直接引用就是直接指向目标的指针、相对偏移量或一个间接定位到目标的句柄。
- 解析动作主要针对类或接口、字段、类方法、接口方法、方法类型等。对应常量池中的
  CONSTANT Class info CONSTANT Fieldref info, CONSTANT Methodref info

### 第三步 初始化

- 初始化阶段就是执行**类的构造器方法 <clinit>()** 的过程（cl可以理解为 class  ，init为 inital）

- 此方法不需要定义，是javac编译器自动收集类中的所有变量的赋值动作和静态代码块中的语句合并而来的。

- 构造器方法按语句顺序执行所有**类变量**（static修饰的成员变量）显式初始化和**静态代码块中语句**

  ```java
  /*这里的话，a最终的值为1
  * 首先在第二步链接的准备阶段，会将a初始化为0
  * 在第三步初始化时，类的构造器方法按照顺序执行，先将a赋值为10，再将a赋值为1，所以最后a=1
  */
  class Demo{
      static{
          a = 10;
      }
      private static int a = 1;
  }
  ```

- **类的构造器方法 <clinit>()** 不同于类的构造函数，==当一个类中不存在类变量的时候，则.class文件中没有<clinit>()==

- 若该类有父类，JVM会保证父类的 <clinit>()执行完毕之后再执行子类的<clinit>()

  ```java
  class Father{
      public static int a = 1;
      static{
          a = 2;
      }
  }
  
  class Son extends Father{
      public static int b = a;
      
      public static void main(String []args){
          //最终的结果为2
          Sysytem.out.println(Son.b);
      }
  }
  ```

- 虚拟机必须保证一个类的<clinit>()方法在多线程下被同步加锁，即==一个类只会被加载一次==、

## 类的加载器

### 类加载器分类

JVM支持**两种**类型的**类加载器**，分别为

1. **引导加载器**(Bootstrap ClassLoader)
2. **自定义加载器(**User-Defined ClassLoader)，**是指继承自ClassLoader的加载器**

---

### 虚拟机自带的加载器

![image-20210718143802701](https://gitee.com/aruul/a-ru-img/raw/master/img/20210718143804.png)

#### 启动类加载器(引导类加载器 Bootstrap ClassLoader)

- 我们不能直接获取到

- java的**核心类库**都是使用**引导类加载器**来进行加载的。
- 这个类加载使用C++/C来实现的，嵌套在JVM内部
- 并不继承于java.lang.ClassLoader
- **加载扩展类和程序类加载器，并指定为它们的父加载器**
- 出于安全考虑，Bootstrap启动类加载器只加载包名为java、javax、sun等开头的类

#### 拓展类加载器(Extension ClassLoader)

- java语言编写
- 派生于ClassLoader类
- 父加载器为启动类加载器
- 从java。ext.dirs系统属性所指定的目录中加载类库，或者从JDK安装目录的jre/lib/ext子目录下加载类库。**如果用户创建的jar在此目录下，也会自动由扩展类加载器加载**

#### 应用程序类加载器(系统类加载器AppClassLoader)

- java语言编写
- 派生于ClassLoader类
- **父加载器为拓展类加载器**
- 负责加载**环境变量classpath**或**系统属性java.class.path**指定路径下的类库
- **我们自己写的类中默认加载器就是应用程序类加载器**

### 用户自定义加载类

![image-20210718151625921](https://gitee.com/aruul/a-ru-img/raw/master/img/20210718151628.png)

## ClassLoader

**ClassLoader类是一个抽象类，其后所有的类加载器都继承自ClassLoader(不包括启动加载类)**

这里暂且了解就够了（嗯，大概

## 双亲委派机制

> Java虚拟机对class文件采用的是**按需加载**的方式，也就是需要的时候才会将它的class文件加载到内存，生成class对象。
>
> 而在加载某个类的class文件时，JVM采用**双亲委派模式**，即把请求交给父类处理，是一种任务委派模式。

**双亲委派机制**：

1. 当一个类加载器收到了加载请求时，它是不会先自己去尝试加载的，而是委派给父类去完成，

2. 如果父类还有父类加载器，则进一步向上委托，以此类推，直到顶层的启动类加载器
3. 如果父类加载器可以完成加载任务，则成功返回；否则，子类加载器尝试去加载

==可以理解为 类加载器这个家族很重亲情，能爸爸做的就爸爸做，爸爸实在做不了就儿子做==

![image-20210718154731162](https://gitee.com/aruul/a-ru-img/raw/master/img/20210718154732.png)

优势：

- 避免类的重复加载

- 保护程序的安全，防止核心api被随意的篡改

  比如你自定义一个包 java.lang,包下面有一个类Demo

  ```java
  package java.lang
  class Demo{
      public static void main(String[] args){
          System.out.println("test");
      }
  }
  ```

  当你运行的时候，由于双亲委派机制，这和Demo类是java开头的，所以最终的加载器是引导类加载器。(引导类加载器只加载包名为java、javax、sun等开头的类)，而java核心类包中并没有Demo这个类，所以就会报错。

## 其他小的点

### 在JVM中表示两个class对象相同的两个必要条件：

1. 类的完整类名要一致，包括包名
2. 加载 这个类的ClassLoader(指ClassLoader实例对象)必须相同。

### 对类加载器的引用

1. JVM必须知道一个类型是由启动加载器加载的还是由用户类加载器加载的。
2. 如果一个类型是由用户类加载器加载的，那么JVM会将这个类加载器的一个引用作为类型信息的一部分保存在方法区中。
3. 当解析一个类型到另一个类型的引用的时候，JVM需要保证这两个类型的类加载器是相同的



----

# 运行时数据区概述和多线程

<img src="https://gitee.com/aruul/a-ru-img/raw/master/img/20210718163557.png" alt="image-20210718163554539" style="zoom:80%;" />

   红色的为**线程共享区域**，**一个虚拟机实例对应一份**

​	**蓝色的是一个线程对应一份**

## 程序计数器(PC计数器)

> **实际上，JVM中的程序计数器(PC计数器)是对物理pc寄存器的一种抽象模拟**，并非是广义上的物理寄存器。
>
> 
>
> 程序计数器其实就是一个指针，它指向了我们程序中下一句需要执行的指令，它也是内存区域中唯一一个不会出现OutOfMemoryError的区域，而且占用内存空间小到基本可以忽略不计。这个内存仅代表当前线程所执行的字节码的行号指示器，字节码解析器通过改变这个计数器的值选取下一条需要执行的字节码指令。
>
> 如果执行的是native方法，那这个指针就不工作了。

**程序计数器其实就是一个指针，它指向了我们程序中下一句需要执行的指令**

**每个线程都有自己的程序计数器**，生命周期与线程一致。

**作用**： PC寄存器用来存储指向下一条指令的地址，也即将要执行的指令代码。由执行引擎读取下一条指令。

下面是一个java代码的字节码文件main方法的一部分：

![image-20210719150122811](https://gitee.com/aruul/a-ru-img/raw/master/img/20210719150124.png)

### 使用PC寄存器存储字节码指令地址有什么用呢？

(为什么使用PC寄存器记录当前线程的执行地址呢？)

因为CPU需要不停的切换各个线程，这时候切换回来以后，就得知道接着从哪开始继续执行。
JVM的字节码解释器就需要通过改变PC寄存器的值来明确下一条应该执行什么样的字节码指令。

### PC寄存器为什么会被设定为线程私有？

cpu在执行多线程的时候，实际上会不停地做任务切换，这样必然导致经常中断或恢复，如何保证分毫无差呢？为了能够准确地记录各个线程正在执行的当前字节码指令地址，最好的办法自然是为每一个线程都分配一个PC寄存器，这样一来各个线程之间便可以进行独立计算，从而不会出现相互干扰的情况。

### 并行 并发

- **并发：** 同一时间段，多个任务都在执行 (单位时间内不一定同时执行)；
- **并行：** 单位时间内，多个任务同时执行（可以与串行相理解）

## 虚拟机栈

**栈管运行，堆管存储。则虚拟机栈负责运行代码，而虚拟机堆负责存储数据。**

> Java虚拟机栈( Java virtua1 Machine Stack),早期也叫Java栈。
> 每个线程在创建时都会创建一个虚拟机栈，其内部保存一个个的栈帧( Stack Frame),对应着一次次的Java方法调用。
>
> **是线程私有的**

- **作用**：主管java程序的运行，它保存方法的局部变量(8中基本数据类型/对象的引用)、部分结果，并参与方法的调用和返回。

- **优点：**1. 栈是一种快速有效的分配存储方式，访问速度仪次于程序计数器。

  ​			2.JVM直接对Java栈的操作只有两个：每个方法执行，伴随着进（入栈、压栈）、执行结束后的出栈工作

  ​			3.对于栈来说不存在垃圾回收问题

#### 异常

如果线程请求的栈的深度大于虚拟机栈的最大深度，就会报 **StackOverflowError** （这种错误经常出现在递归中）。

Java虚拟机也可以动态扩展，但随着扩展会不断地申请内存，当无法申请足够内存时就会报错 **OutOfMemoryError**(OOM)。

#### 设置栈内存大小

我们可以使用参数-Xss选项来设置线程的最大栈空间，栈大小直接决定了函数调用的最大可达深度。

#### 栈的存储单元-栈帧

- 每个线程都有自己的栈，栈中的数据都是以**栈帧( Stack Frame)**格式存在。
- 在这个线程上正在执行的**每个方法**都各自**对应一个栈帧( Stack Frame)**
- 栈帧是一个内存区块，是一个数据集，维系着方法执行过程中的各种数据信息。
- 在一条活动线程中，一个时间点上，只会有一个活动的栈帧。
  - 即只有当前正在执行的方法的栈帧（**栈顶栈帧**）是有效的，这个栈帧被称为**当前栈帧( Current Frame)**,
  - 与**当前栈帧相对应的方法就是当前方法**（ CurrentMethod),
  - 定义这个方法的类就是**当前类**( Current Class).
- **执行引擎运行的所有字节码指令只针对当前栈帧进行操作**
  如果在该方法中调用了其他方法，对应的新的栈帧会被创建出来，放在栈的顶端，成为新的当前帧。

<img src="https://gitee.com/aruul/a-ru-img/raw/master/img/20210719160147.png" alt="QQ图片20210719160131" style="zoom:80%;" />

- Java方法有两种返回函数的方式，一种是正常的函数返回，使用 return指令；另外一种是抛出异常。**不管使用哪种方式，都会导致栈帧被弹出。**
- 不同线程中所包含的栈帧是不允许存在相互引用的，即不可能在一个栈帧之中引用另外一个线程的栈帧。
- 如果当前方法调用了其他方法，方法返回之际，当前栈帧会传回此方法的执行结果给前一个栈帧，接着，虚拟机会丢弃当前栈帧，使得前一个栈帧重新成为当前栈帧

#### 栈帧的内部结构【ToDo】

(这里我并没有仔细看，所以只粗略了写了一小点内容)

![image-20210719161844500](https://gitee.com/aruul/a-ru-img/raw/master/img/20210719161847.png)

- 局部变量表( Local Variables)

  ​     **定义为数字数组**

  ​	**局部变量表，最基本的存储单元是Slot（变量槽）**

  ![image-20210719162352247](https://gitee.com/aruul/a-ru-img/raw/master/img/20210719162353.png)

- 操作数栈( operand stack)（或表达式）

- 动态链接( Dynamic Linking)（或指向运行时常量池的方法引用）

- 方法返回地址( Return Address)（或方法正常退出或者异常退出的定义）

- 一些附加信息

#### 静态变量和局部变量

  **局部变量在使用前一定要显式赋值，否则编译不通过**

> 我们知道类变量表有两次初始化的机会，第一次是在“准备阶段”，执行系统初始化，对类变量设置零值，
>
> 另一次则是在“初始化”阶段，赋予程序员在代码中定义的初始值。
> 和类变量初始化不同的是，局部变量表不存在系统初始化的过程，这意味着一旦定义了局部变量则必须人为的初始化，否则无法使用。

**补充：**

- 在栈帧中，与性能调优关系最为密切的部分就是前面提到的局部变量表。在方法执行时，虚拟机使用局部变量表完成方法的传递。
- 局部变量表中的变量也是重要的垃圾回收根节点，只要被局部变量表中直接或间接引用的对象都不会被回收。

#### 举例栈溢出的情况？

如果线程请求的栈的深度大于虚拟机栈的最大深度，就会报 **StackOverflowError** （这种错误经常出现在递归中）。

#### 调整栈大小，就能保证不出现溢出吗？

使用参数-Xss选项来设置线程的最大栈空间，但不一定保证不出现溢出，如果碰到递归，可能会出现溢出。

#### 分配的栈内存越大越好吗？

并不是，栈是私有的，如果设置的每一个栈的空间太大了，就会导致最后可分配的线程数量变少，甚至出OOM

#### 垃圾回收是否会涉及到虚拟机栈？

不会，他直接操作的就是出栈、入栈，不存在GC(垃圾回收)，存在Error

#### 方法中定义的局部变量是否线程安全？【ToDo】

视情况而定

## 本地方法接口的理解

p63



